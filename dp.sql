-- MySQL dump 10.16  Distrib 10.1.43-MariaDB, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: task_base
-- ------------------------------------------------------
-- Server version	10.1.43-MariaDB-1~xenial

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `task_base`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `task_base` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci */;

USE `task_base`;

--
-- Table structure for table `contests`
--

DROP TABLE IF EXISTS `contests`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `contests` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  `year` int(11) NOT NULL,
  `description` mediumtext COLLATE utf8_unicode_ci,
  `link` varchar(200) COLLATE utf8_unicode_ci NOT NULL,
  `tutorial` varchar(100) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `contests`
--

LOCK TABLES `contests` WRITE;
/*!40000 ALTER TABLE `contests` DISABLE KEYS */;
INSERT INTO `contests` VALUES (1,'ЛОШ-2019, 1 смена, Информатика+Информатика, день 1.',2019,'Контест на простую динамику + одна задача на следующую тему.','https://contest.yandex.ru/contest/12972/standings/',''),(2,'ЛОШ-2019, 1 смена, Информатика+Информатика, день 2.',2019,'Контест на более сложную динамику --- рюкзак, НОП, НВП, зачем-то дубы))','https://contest.yandex.ru/contest/12972/standings/',''),(3,'ЛОШ-2019, 1 смена, Информатика+Информатика, день 3.',2019,'Задачи в основном на z и префикс функцию, хешей нет.','https://contest.yandex.ru/contest/12972/standings/',''),(4,'ЛОШ-2019, 1 смена, Информатика+Информатика, день 4.',2019,'Простая геометрия на тему попересекать объекты','https://contest.yandex.ru/contest/12972/standings/',''),(5,'ЛОШ-2019, 1 смена, Информатика+Информатика, день 5.',2019,'Задачки на обход графа в глубину','https://contest.yandex.ru/contest/12972/standings/',''),(6,'ЛОШ-2019, 1 смена, Информатика+Информатика, день 6.',2019,'Задачи на обход в ширину и дейкстру','https://contest.yandex.ru/contest/12972/standings/',''),(7,'ЛОШ-2019, 1 смена, Информатика+Информатика, день 7.',2019,'Флойд, Форд-Беллман','https://contest.yandex.ru/contest/12972/standings/',''),(8,'ЛОШ-2019, 1 смена, Информатика+Информатика, день 8.',2019,'Простые задачи на теорию чисел. Не надо ставить это на последний день, тема не простая.','https://contest.yandex.ru/contest/12972/standings/',''),(9,'ЛОШ-2019, 1 смена, Информатика Профи, день 1',2019,'Продвинутая геометрия + выпуклая оболочка\r\n\r\nКажется, здесь не хватает задач','https://contest.yandex.ru/contest/12973/standings/',''),(10,'ЛОШ-2019, 1 смена, Информатика Профи, день 2',2019,'Динамика по профилю, изломанному профилю и подмножествам','https://contest.yandex.ru/contest/12973/standings/',''),(11,'ЛОШ-2019, 1 смена, Информатика Профи, день 3',2019,'Теория игр','https://contest.yandex.ru/contest/12973/standings/',''),(12,'ЛОШ-2019, 1 смена, Информатика Профи, день 4',2019,'Бор, Ахо-Корасик','https://contest.yandex.ru/contest/12973/standings/',''),(13,'ЛОШ-2019, 1 смена, Информатика Профи, день 5',2019,'STL + дерево отрезков + sqrt декомпозиция','https://contest.yandex.ru/contest/12973/standings/',''),(14,'ЛОШ-2019, 1 смена, Информатика Профи, день 6',2019,'Декартово дерево по явному ключу','https://contest.yandex.ru/contest/12973/standings','');
/*!40000 ALTER TABLE `contests` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tags`
--

DROP TABLE IF EXISTS `tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag` varchar(100) NOT NULL,
  `parent` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `tag` (`tag`),
  KEY `parent` (`parent`),
  CONSTRAINT `tags_ibfk_1` FOREIGN KEY (`parent`) REFERENCES `tags` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=63 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tags`
--

LOCK TABLES `tags` WRITE;
/*!40000 ALTER TABLE `tags` DISABLE KEYS */;
INSERT INTO `tags` VALUES (6,'dp',NULL),(7,'linear',6),(8,'square',6),(9,'find answer',6),(11,'game theory',NULL),(12,'knapsack',6),(13,'cube',6),(14,'LCS',6),(15,'LIC',6),(16,'substring',6),(17,'subsegment',6),(18,'string',NULL),(19,'z-function',18),(20,'prefix-function',18),(21,'KMP',20),(22,'geometry',NULL),(23,'base',22),(24,'polygon',22),(25,'graph',NULL),(26,'dfs',25),(27,'bfs',25),(28,'find path',25),(29,'box',25),(30,'dijkstra',25),(31,'bellman-ford algorithm',25),(32,'floyd-warshall algorithm',25),(33,'unusual',NULL),(34,'Convex hull',22),(35,'binary search',NULL),(36,'subset',6),(37,'profile',6),(38,'broken profile',37),(39,'retroanalys',11),(40,'nim',11),(41,'tree',25),(42,'SCC',NULL),(43,'trie',18),(44,'STL',NULL),(45,'Aho-Corasick',43),(46,'hash',18),(47,'bitwise trie',43),(48,'Number theory',NULL),(50,'gcd',48),(51,'Sieve of Eratosthenes',48),(52,'LCM',48),(53,'Binpow',48),(54,'segment tree',59),(55,'sqrt decomposition',59),(56,'prefix sum',59),(57,'right bracket sequence',59),(58,'treap',59),(59,'data structure',NULL),(60,'explicit key',58),(61,'not explicit key',58),(62,'interactive',NULL);
/*!40000 ALTER TABLE `tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tags_task`
--

DROP TABLE IF EXISTS `tags_task`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tags_task` (
  `task_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  KEY `task_id` (`task_id`),
  KEY `tag_id` (`tag_id`),
  CONSTRAINT `tags_task_ibfk_1` FOREIGN KEY (`task_id`) REFERENCES `tasks` (`id`),
  CONSTRAINT `tags_task_ibfk_2` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tags_task`
--

LOCK TABLES `tags_task` WRITE;
/*!40000 ALTER TABLE `tags_task` DISABLE KEYS */;
INSERT INTO `tags_task` VALUES (73,6),(73,8),(74,6),(74,9),(74,7),(75,6),(75,11),(75,7),(76,6),(76,8),(77,6),(77,12),(77,8),(78,6),(78,7),(77,9),(79,6),(79,13),(79,9),(79,14),(80,6),(80,8),(80,12),(81,6),(81,8),(81,9),(81,14),(80,9),(82,6),(82,8),(82,15),(83,6),(83,8),(84,6),(84,8),(84,17),(84,9),(85,18),(85,19),(86,18),(86,20),(87,18),(87,20),(87,19),(87,21),(89,18),(89,20),(91,22),(91,23),(92,22),(92,23),(93,22),(93,23),(94,22),(94,23),(94,24),(95,22),(95,23),(96,22),(96,23),(97,22),(97,23),(98,22),(98,23),(99,22),(99,23),(100,22),(100,24),(101,22),(101,23),(102,25),(102,26),(103,25),(103,26),(103,27),(102,27),(104,25),(104,26),(104,28),(105,25),(105,26),(105,28),(106,25),(106,28),(106,26),(108,27),(108,25),(109,27),(109,25),(110,25),(110,29),(110,27),(111,30),(111,25),(112,30),(112,25),(115,32),(115,25),(116,25),(116,32),(117,25),(117,31),(118,25),(118,32),(118,33),(119,25),(119,31),(120,22),(120,23),(121,22),(121,23),(122,22),(122,34),(123,22),(123,34),(124,22),(124,35),(125,22),(125,34),(124,24),(126,36),(126,6),(127,36),(127,6),(128,36),(128,6),(129,6),(129,7),(129,37),(130,6),(130,38),(130,37),(133,6),(133,38),(134,11),(134,40),(135,11),(135,39),(135,41),(137,11),(137,39),(138,11),(138,40),(138,39),(139,11),(139,39),(139,40),(88,20),(88,19),(88,18),(114,25),(114,31),(107,25),(107,28),(107,27),(136,11),(136,25),(136,39),(132,6),(132,37),(131,6),(131,36),(72,6),(72,7),(90,18),(90,20),(90,6),(90,7),(140,25),(140,26),(140,11),(140,39),(141,11),(141,39),(142,40),(142,11),(143,18),(143,43),(143,44),(144,18),(144,43),(144,45),(145,18),(145,43),(146,18),(146,19),(146,44),(146,46),(147,18),(147,43),(147,47),(149,18),(149,43),(149,45),(148,18),(148,43),(148,45),(113,25),(113,35),(113,28),(113,30),(150,48),(150,50),(150,52),(151,48),(151,51),(152,48),(152,53),(153,48),(153,53),(154,48),(154,50),(155,48),(156,48),(156,51),(157,44),(157,54),(158,44),(158,54),(159,44),(160,44),(161,54),(162,55),(163,56),(164,57),(164,54),(165,54),(165,55),(165,58),(165,59),(165,60),(166,58),(166,59),(166,60),(166,44),(167,58),(167,59),(167,60),(168,58),(168,59),(168,60),(169,35),(169,58),(169,59),(169,60),(169,62),(170,58),(170,59),(170,60),(171,17),(171,6),(172,58),(172,59),(172,60),(172,54);
/*!40000 ALTER TABLE `tags_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tasks`
--

DROP TABLE IF EXISTS `tasks`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tasks` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(500) NOT NULL,
  `complexity` int(11) DEFAULT NULL,
  `statement` mediumtext,
  `short_statement` varchar(10000) NOT NULL,
  `tutorial` mediumtext,
  `source` varchar(10000) DEFAULT NULL,
  `todo` mediumtext,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=173 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tasks`
--

LOCK TABLES `tasks` WRITE;
/*!40000 ALTER TABLE `tasks` DISABLE KEYS */;
INSERT INTO `tasks` VALUES (72,'Платная лестница',7,'Мальчик подошел к платной лестнице. Чтобы наступить на любую ступеньку, нужно заплатить указанную на ней сумму. Мальчик умеет перешагивать на следующую ступеньку, либо перепрыгивать через ступеньку. Требуется узнать, какая наименьшая сумма понадобится мальчику, чтобы добраться до верхней ступеньки.\r\n\r\nФормат ввода\r\nВ первой строке входного файла вводится одно натуральное число N () — количество ступенек. В следующей строке вводятся N натуральных чисел, не превосходящих 100 — стоимости ступенек (снизу вверх).\r\n\r\nФормат вывода\r\nВыведите одно число — наименьшую возможную стоимость прохода по лесенке.','Лесенка, прыжки на следующую и через одну, набрать минимум, N <= 100','Простая одномерная динамика','ЯК 12972 A1',''),(73,'Черепашка',9,'В левом верхнем углу прямоугольной таблицы размером N × M находится черепашка. В каждой клетке таблицы записано некоторое число. Черепашка может перемещаться вправо или вниз, при этом маршрут черепашки заканчивается в правом нижнем углу таблицы.\r\n\r\nПодсчитаем сумму чисел, записанных в клетках, через которую проползла черепашка (включая начальную и конечную клетку). Найдите наибольшее возможное значение этой суммы.\r\n\r\nФормат ввода\r\nВ первой строке входных данных записаны два натуральных числа N и M, не превосходящих 100 — размеры таблицы. Далее идут N строк, каждая из которых содержит M чисел, разделенных пробелами — описание таблицы. Все числа в клетках таблицы целые и могут принимать значения от 0 до 239.\r\n\r\nФормат вывода\r\nПрограмма должна вывести единственное число: максимальную возможную стоимость маршрута черепашки.','Черепашка перемещается вниз и вправо. Дойти до нижнего правого угла с максимальной суммой','Простая двумерная динамика','ЯК 12972 B1',''),(74,'Калькулятор',10,'Имеется калькулятор, который выполняет следующие операции:\r\n\r\nУмножить число X на 2.\r\nУмножить число X на 3.\r\nПрибавить к числу X единицу.\r\nОпределите, какое наименьшее количество операций требуется, чтобы получить из числа 1 число N.\r\n\r\nФормат ввода\r\nВ первой строке задается натуральное число N, не превосходящее 106.\r\n\r\nФормат вывода\r\nВыведите минимальное количество операций. Во второй строке выведите числа, последовательно получающиеся при выполнении операций. Первое из них должно быть равно 1, а последнее N.\r\n\r\n','Можно *= 2, *= 3, += 1; Из 1 получить число за минимальное число шагов и восстановить ответ','dp[i] - ответ на задачу','ЯК 12972 C1',''),(75,'Камни',9,'На столе лежат N камней. За ход игрок может взять:\r\n\r\n1 или 2 камня, если N делится на 3;\r\n1 или 3, если N при делении на 3 дает остаток один;\r\n1, 2 или 3, если N при делении на 3 дает остаток два.\r\nКаждый ход можно сделать при наличии достаточного количества камней. Проигрывает тот, кто хода сделать не может.\r\n\r\nФормат ввода\r\nВводится целое число 0 < N ≤ 100.\r\n\r\nФормат вывода\r\nВыведите 1 или 2 — номер игрока, который выиграет при правильной игре.','Из кучи камней по простым правилам можно забирать камни, сказать, кто выиграет','Либо простое dp, либо можно доказать, что первый проигрывает только если число камней делится на 3.','ЯК 12972 D1',''),(76,'Попытка бегства',11,'Узник пытается бежать из замка, который состоит из N × M квадратных комнат, расположенных в виде прямоугольника N × M. Между любыми двумя соседними комнатами есть дверь, однако некоторые комнаты закрыты и попасть в них нельзя. В начале узник находится в левой верхней комнате и для спасения ему надо попасть в противоположную правую нижнюю комнату. Времени у него немного, всего он может побывать не более, чем в N + M - 1 комнате на своем пути, то есть перемещаться он должен только вправо или вниз. Определите количество маршрутов, которые ведут к выходу.\r\n\r\nФормат ввода\r\nПервая строчка входных данных содержит натуральные числа N и M, не превосходящие 1000. Далее идет план замка в виде N строчек по M чисел в каждой. Одно число соответствует одной комнате: «1» означает, что в комнату можно попасть, «0» — что комната закрыта.\r\n\r\nФормат вывода\r\nПрограмма должна напечатать количество маршрутов, ведущих узника к выходу и проходящих через M + N - 1 комнату, или слово «Impossible», если таких маршрутов не существует.\r\n\r\nВходные данные подобраны таким образом, что искомое число маршрутов не превосходит 2 ⋅ 109.','В таблице некоторые клетки непроходимы, ходить можно вправо и вниз, найти количество путей.','Квадратное дп, которое учитывает непроходимые клетки','ЯК 12972 E1',''),(77,'Банкомат',14,'В некотором государстве в обращении находятся банкноты определенных номиналов. Национальный банк хочет, чтобы банкомат выдавал любую запрошенную сумму при помощи минимального числа банкнот, считая, что запас банкнот каждого номинала неограничен. Помогите Национальному банку решить эту задачу.\r\n\r\nФормат ввода\r\nПервая строка входных данных содержит натуральное число N не превосходящее 100 — количество номиналов банкнот в обращении. Вторая строка входных данных содержит N различных натуральных чисел x1, x2, …, xN, не превосходящих 106 — номиналы банкнот. Третья строчка содержит натуральное число S, не превосходящее 106 — сумму, которую необходимо выдать.\r\n\r\nФормат вывода\r\nВ первую строку выходного файла выведите минимальное число слагаемых (или -1, если такого представления не существует). Во вторую строку выведите это представление в любом порядке.','Вариация рюкзака, где каждого достоинства бесконечно много, требуется набрать сумму используя как можно меньше купюр.','dp[i] - Ответ на задачу. Постепенно добавляя новые купюры его пересчитываем как dp[i] = min(dp[i], dp[i - a[j]] + 1)','ЯК 12972 F1',''),(78,'Гвоздики',14,'В дощечке в один ряд вбиты гвоздики. Любые два гвоздика можно соединить ниточкой. Требуется соединить некоторые пары гвоздиков ниточками так, чтобы к каждому гвоздику была привязана хотя бы одна ниточка, а суммарная длина всех ниточек была минимальна.\r\n\r\nФормат ввода\r\nВ первой строке входных данных записано число N — количество гвоздиков (). В следующей строке заданы N чисел — координаты всех гвоздиков (неотрицательные целые числа, не превосходящие 10000).\r\n\r\nФормат вывода\r\nВыведите единственное число — минимальную суммарную длину всех ниточек.','На прямой есть гвозди, на каждом должна быть натянута нить. Найти минимальную длину нити.','dp[i] - ответ для первых i гвоздей, причем на i-м точно есть нить. \r\ndp[i] = min(dp[i - 1], dp[i - 2]) + a[i] - a[i - 2]\r\nГвоздики не отсортированы!!','ЯК 12972 G1',''),(79,'Кино 3D',16,'Трое друзей летом посмотрели несколько 3D-фильмов. Для каждого школьника известно, какие 3D-фильмы и в каком порядке он посмотрел (естественно, если фильм кому-то из ребят сильно понравился, он мог его пересмотреть несколько раз). Так как друзья любят смотреть фильмы вместе, втроем они посмотрели максимальное возможное количество. Сколько же раз они встречались вместе?\r\n\r\nФормат ввода\r\nВ первой строке входного файла заданы три числа: N, M и K — количества 3D-фильмов, просмотренных каждым из друзей (). В следующих трех строках выписаны номера 3D-фильмов, просмотренных ими. У друзей огромные планы на будущее, поэтому 3D-фильмы нумеруются числами между 1 и 109.\r\n\r\nФормат вывода\r\nВ первой строке выведите единственное число — максимальное кол-во просмотренных 3D-фильмов. В следующей строке выведите через пробел номера просмотренных 3D-фильмов в порядке просмотра.\r\n\r\n','Даны три последовательности, найти их НОП.','dp[i][j][k] - ответ на соответствующих префиксах.','ЯК 12972 H1',''),(80,'Рюкзак',13,'Найдите максимальный вес золота, который можно унести в рюкзаке вместительностью S, если есть N золотых слитков с заданными весами.\r\n\r\nФормат ввода\r\nВ первой строке входного файла записаны два числа — S и N (, ).\r\n\r\nДалее следует N неотрицательных целых чисел, не превосходящих 100 000 — веса слитков.\r\n\r\nФормат вывода\r\nВыведите искомый максимальный вес.','Классический рюкзак - набрать наибольший возможный вес, используя данные камни','dp[i][w] - можем ли набрать вес w используя первые i камней','ЯК 12972 A2',''),(81,'Наибольшая общая подпоследовательность',14,'Общей подпоследовательностью двух строк s1 и s2 называется пара последовательностей индексов ({ai},{bi}) такая, что a1 < a2 < … < ak, b1 < b2 < … < bk, and s1[ai]=s2[bi] for all 1≤ i≤ k.\r\n\r\nНайдите наибольшую общую подпоследовательность двух строк.\r\n\r\nФормат ввода\r\nПервая и вторая строки входа содержат две непустые строки, каждая из которых состоит из строчных латинских букв. Длина каждой строки не превосходит 100.\r\n\r\nФормат вывода\r\nВ первой строке выведите целое число k — длину наибольшей общей подпоследовательности. Во второй выведите k целых чисел — индексы символов наибольшей общей подпоследовательности в первой строке, отсортированные по возрастанию. В третьей, аналогично — отсортированные по возрастанию индексы символов наибольшей общей подпоследовательности во второй строке. Символы в строках занумерованы с 1.\r\n\r\nЕсли способов выбрать наибольшую общую подпоследовательность несколько, выведите любой из них.','Найти НВП двух строк','dp[i][j] - длина НВП для i-о префикса одной строки и j-о префикса другой','ЯК 12972 B2',''),(82,'Наибольшая последовательнократная подпоследовательность',13,'Для заданной числовой последовательности  требуется найти длину максимальной последовательнократной подпоследовательности.\r\n\r\nДля последовательнократной подпоследовательности  () верно, что aki | akj при  (утверждение «a|b» эквивалентно «b кратно a»). Подпоследовательность из одного элемента полагается последовательнократной по определению.\r\n\r\nФормат ввода\r\nВ первой строке входного файла записано одно натуральное число N () — количество чисел в исходной последовательности. Далее следует N натуральных чисел, не превосходящих 2⋅109 — сама последовательность.\r\n\r\nФормат вывода\r\nВывести единственное число, равное искомому количеству.','Найти длину наибольшей подпоследовательности, в которой каждое следующее число делится на предыдущее','dp[i] - длина ответа, заканчивающемся в i-й позиции','ЯК 12972 C1',''),(83,'Лесенки',12,'Лесенкой называется набор кубиков, в котором каждый горизонтальный слой содержит меньше кубиков, чем слой под ним. Требуется подсчитать количество различных лесенок, которые могут быть построены из N кубиков.\r\n\r\nФормат ввода\r\nВо входном файле вводится одно целое число N ().\r\n\r\nФормат вывода\r\nВыведите искомое количество лесенок.','Посчитать количество разбиений на слагаемые без повторений','dp[n][k] - количество лесенок из n кубиков, на самом большом слое не более k кубиков.\r\n\r\ndp[n][k] = dp[n][k - 1] + dp[n - k][min(k - 1, n - k)]','ЯК 12972 D2',''),(84,'Дубы',50,'На аллее перед зданием Министерства Обороны в ряд высажены n дубов. В связи с грядущим приездом главнокомандующего, было принято решение срубить несколько деревьев для придания аллее более милитаристического вида.\r\n\r\nВнутренние распорядки министерства позволяют срубать дуб только в двух случаях:\r\n\r\nесли и ближайший дуб слева, и ближайший дуб справа строго ниже, чем данный дуб;\r\nесли и ближайший дуб слева, и ближайший дуб справа строго выше, чем данный дуб.\r\nВ частности, согласно этому правилу, нельзя срубить крайний левый и крайний правый дубы.\r\n\r\nМинистр хочет выработать такой план вырубки, чтобы в итоге осталось несколько дубов, высоты которых образуют неубывающую последовательность, то есть чтобы каждый дуб был не ниже, чем все дубы, стоящие слева от него. При этом, как человек любящий флору, министр хочет, чтобы было срублено минимальное возможное количество деревьев.\r\n\r\nПомогите сотрудникам министерства составить оптимальный план вырубки аллеи или выяснить, что срубить дубы соответствующим образом невозможно.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит целое число n — количество дубов, растущих на аллее (). Вторая строка содержит n чисел — высоты дубов, приведённые слева направо. Высоты дубов — положительные целые числа, не превышающие 1 000.\r\n\r\nФормат вывода\r\nЕсли оставить последовательность дубов с неубывающими высотами невозможно, выходной файл должен содержать только одно число -1.\r\n\r\nВ случае, если искомый план существует, в первую строку выходного файла выведите целое число m — минимальное количество дубов, которые необходимо срубить. В следующие m строк выведите оптимальный план вырубки деревьев — номера дубов в том порядке, в котором их следует срубать, по одному номеру на строке.\r\n\r\nДубы нумеруются слева направо натуральными числами от 1 до n.\r\n\r\nЕсли планов с наименьшим числом срубаемых дубов несколько, выведите любой из них.','Дан массив, можно удалять только элементы, которые больше соседей или меньше соседей. Надо получить неубывающую подпоследовательность, вырубив как можно меньше. n <= 200','','ЯК 12972 E2',''),(85,'Z-функция',16,'Дана непустая строка S, длина которой N не превышает 106. Будем считать, что элементы строки нумеруются от 1 до N.\r\n\r\nТребуется для всех i от 1 до N вычислить её z-функцию z[i].\r\n\r\nФормат ввода\r\nОдна строка длины N, , состоящая из маленьких латинских букв.\r\n\r\nФормат вывода\r\nВыведите N чисел — значения z-функции для каждой позиции, разделённые пробелом.','Посчитать Z-функцию','https://neerc.ifmo.ru/wiki/index.php?title=Z-функция','ЯК 12972 A3',''),(86,'Префикс-функция',17,'Дана непустая строка S, длина которой N не превышает 106. Будем считать, что элементы строки нумеруются от 1 до N.\r\n\r\nТребуется для всех i от 1 до N вычислить её префикс-функцию .\r\n\r\nФормат ввода\r\nОдна строка длины N, , состоящая из маленьких латинских букв.\r\n\r\nФормат вывода\r\nВыведите N чисел — значения префикс-функции для каждой позиции, разделённые пробелом.','Посчитать префикс-функцию','https://neerc.ifmo.ru/wiki/index.php?title=Префикс-функция','ЯК 12972 B3',''),(87,'Дана строка',16,'Даже больше \"— дано две строки,  и . Вам требуется узнать, где в строке  можно найти строку  как подстроку и выписать все такие позиции.\r\n\r\nФормат ввода\r\nВ первой строке входного файла содержится строка , во второй \"— строка . Строки состоят только из строчных латинских букв (a–z), их длины не превосходят 100 000.\r\n\r\nФормат вывода\r\nВ первой строке выходного файла выведите одно число \"— количество вхождений строки  в строку . Во второй строке для каждого вхождения выведите номер символа в строке , где начинается очередная строка . Вхождения нужно выводить в возрастающем порядке.','Найти все вхождения одной строки в другую','Применить префикс или z функцию','ЯК 12972 C3',''),(88,'Кубики',16,'Привидение Петя любит играть со своими кубиками. Он любит выкладывать их в ряд и разглядывать своё творение. Однако недавно друзья решили подшутить над Петей и поставили в его игровой комнате зеркало. Ведь всем известно, что привидения не отражаются в зеркале! А кубики отражаются.\r\n\r\nТеперь Петя видит перед собой N цветных кубиков, но не знает, какие из этих кубиков настоящие, а какие — всего лишь отражение в зеркале.\r\n\r\n\r\nПомогите Пете! Выясните, сколько у него может быть кубиков. Петя видит отражение всех кубиков в зеркале и часть кубиков, которая находится перед ним. Часть кубиков может быть позади Пети, их он не видит.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит два целых числа: N () и количество различных цветов, в которые могут быть раскрашены кубики, — M (). Следующая строка содержит N целых чисел от 1 до M — цвета кубиков.\r\n\r\nФормат вывода\r\nВ выходной файл выведите в порядке возрастания все такие K, что у Пети может быть K кубиков.\r\n\r\n','Приведение видит перед собой кубики. Где-то в этом ряду стоит зеркало. Найти все позиции, на которых оно может стоять.','Заметим, что если зеркало стоит в i-й позиции, то на i-м префиксе совпадает первая половина и перевернутая вторая. Будем перебирать позицию зеркала и проверять на равенство две эти строки при помощи z-функции. Это можно сделать, если к нашей строке дописать перевернутую такую-же.\r\n\r\nУтверждается, что ее можно как-то решить префикс-функцией.','ЯК 12972 D3','В этой задаче заходит квадратное решение - надо поднять ограничения'),(89,'Основание строки',16,'Строка S была записана много раз подряд, после чего из получившейся строки взяли подстроку и дали вам. Ваша задача определить минимально возможную длину исходной строки S.\r\n\r\nФормат ввода\r\nВ первой и единственной строке входного файла записана строка, которая содержит только латинские буквы, длина строки не превышает 50 000 символов.\r\n\r\nФормат вывода\r\nВ выходной файл выведите ответ на задачу.','Найти минимальный период строки','Можно легко доказать, что ответом является префикс строки длины s.size() - p.back(), где p - префикс-функция','ЯК 12972 E3',''),(90,'Retrostring',40,'S\r\n  называется последовательность символов \r\nS\r\n1\r\n,\r\n.\r\n.\r\n.\r\n,\r\nS\r\nn\r\n, где \r\n|\r\nS\r\n|\r\n=\r\nn\r\n — это длина строки \r\nS\r\n.\r\nДля любого \r\nk\r\n (\r\n1\r\n≤\r\nk\r\n≤\r\n|\r\nS\r\n|\r\n) \r\nk\r\n-м префиксом строки \r\nS\r\n называется строка \r\nS\r\n1\r\n,\r\n.\r\n.\r\n.\r\n,\r\nS\r\nk\r\n длины \r\nk\r\n. Если \r\nk\r\n<\r\n|\r\nS\r\n|\r\n, то префикс называется собственным.\r\nАналогично для любого \r\nk\r\n (\r\n1\r\n≤\r\nk\r\n≤\r\n|\r\nS\r\n|\r\n) \r\nk\r\n-м суффиксом строки \r\nS\r\n называется строка \r\nS\r\n|\r\nS\r\n|\r\n−\r\nk\r\n+\r\n1\r\n,\r\n.\r\n.\r\n.\r\n,\r\nS\r\n|\r\nS\r\n|\r\n длины \r\nk\r\n. Если \r\nk\r\n<\r\n|\r\nS\r\n|\r\n, то суффикс также называется собственным.\r\nНазовём числом повторяемости строки \r\nS\r\n количество её различных собственных суффиксов, каждый из которых совпадает с префиксом той же длины, что и этот суффикс.\r\nНазовём строку ретрострокой, если её число повторяемости строго больше чисел повторяемости всех её собственных префиксов.\r\nДана строка \r\nS\r\n. Нужно найти её префикс максимальной длины (не обязательно собственный), являющийся ретрострокой.\r\n\r\nФормат ввода\r\nВ первой строке входного файла записана строка \r\nS\r\n, \r\n1\r\n≤\r\n|\r\nS\r\n|\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\n0\r\n. Строка содержит лишь символы с ASCII-кодом от 33 до 126.\r\nФормат вывода\r\nВ первой строке выходного файла должен быть выведен префикс \r\nS\r\n максимальной длины, являющийся ретрострокой.','Найти префикс с наибольшим количеством супрефиксов (бордеров)','Заметим, что количество супрефиксов можно легко посчитать при помощи динамики на префикс-функции.','ЯК 12972 F3','Переделать сложности'),(91,'Угол между векторами',4,'Даны два вектора. Найдите полярный угол между ними.\r\n\r\nФормат ввода\r\nЧетыре числа — координаты двух ненулевых векторов.\r\n\r\nФормат вывода\r\nОдно число — величина неориентированного угла между ними с точностью до пятого знака после запятой из интервала [0, PI].','Найти угол между векторами','Just use atan2','ЯК 12972 A4',''),(92,'Расстояние от точки до отрезка',9,'Определите расстояние от точки до отрезка.\r\n\r\nФормат ввода\r\nЗадано 6 целых чисел от -10 000 до 10 000, разделенных пробелами: точка (x,y) и две точки (x1, y1), (x2, y2), являющиеся концами отрезка. Концы отрезка могут совпадать.\r\n\r\nФормат вывода\r\nВыведите искомое расстояние с точностью не менее 5 знаков после десятичной точки.','Найти расстояние от точки до отрезка','Найдем расстояние от точки до прямой. Если перпендикуляр не падает на отрезок, то ответ - минимум из расстояний до его концов','ЯК 12972 B4',''),(93,'Проверка пересечения отрезков',35,'Даны два отрезка. Требуется выяснить, пересекаются ли они.\r\n\r\nФормат ввода\r\nВосемь чисел – координаты концов двух отрезков, по модулю не превосходящие 104.\r\n\r\nФормат вывода\r\nОдна строка “YES”, если отрезки имеют общие точки, и “NO” в противном случае.\r\n\r\n','Проверить, пересекаются ли отрезки','Главная идея - проверить, что концы каждого отрезка лежат по разные стороны от другого + немного подумать о крайних случаях.','ЯК 12972 C4',''),(94,'Площадь многоугольника',15,'Задан многоугольник координатами точек в порядке обхода. Вам необходимо найти площадь многоугольника.\r\nФормат ввода\r\nВо входном файле находятся число \r\nN\r\n — количество точек многоугольника(\r\n3\r\n≤\r\nN\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\n).\r\nВ следующих \r\nN\r\n сроках записаны в порядке обхода пары целых чисел от \r\n−\r\n1\r\n0\r\n0\r\n0\r\n0\r\n до \r\n1\r\n0\r\n0\r\n0\r\n0\r\n, задающих координаты соответствующих точек многоугольника.\r\n\r\nФормат вывода\r\nВ выходной файл выведите одно число — площадь многоугольника с точностью до \r\n5\r\n-го знака.','Посчитать площадь многоугольника','Методом трапеций или методом треугольников.','ЯК 12972 D4',''),(95,'Точка пересечения прямых',13,'На плоскости даны две прямые. Каждая прямая задается парой точек, через которые она проходит. Требуется установить, пересекаются ли эти прямые, и найти координаты точки пересечения.\r\n\r\nФормат ввода\r\nВводятся сначала координаты двух различных точек, через которые проходит первая прямая, а затем — координаты еще двух различных (но, быть может, совпадающих с первыми двумя) точек, через которые проходит вторая прямая. Координаты каждой точки - целые числа, по модулю не превышающие 1000.\r\n\r\nФормат вывода\r\nЕсли прямые не пересекаются, выведите одно число 0. Если прямые совпадают, выведите 2. Если прямые пересекаются ровно в одной точке, то выведите сначала число 1, а затем два вещественных числа — координаты точки пересечения. Допустимая абсолютная погрешность — 10-2.\r\n\r\n','Найти точку пересечения прямых','Можно через уравнения с определителями, можно через векторную запись уравнений прямых','ЯК 12972 E4',''),(96,'Точка пересечения медиан',5,'Дан невырожденный треугольник. Найти координаты точки пересечения медиан.\r\n\r\nФормат ввода\r\nВход содержит координаты трех точек, не лежащих на одной прямой: X1, Y1, X2, Y2, X3, Y3. Все числа целые, по модулю не превосходят 106.\r\n\r\nФормат вывода\r\nВыведите два числа X и Y, задающие координаты точки пересечения медиан в треугольнике, образованном исходными точками, с точностью не менее 5 знаков после десятичной точки.','Найти точку пересечения медиан','Найти среднее арифметическое данных чисел','ЯК 12972 F4',''),(97,'Точка пересечения биссектрис',20,'Дан невырожденный треугольник. Найти координаты точки пересечения биссектрис.\r\n\r\nФормат ввода\r\nВход содержит координаты трех точек, не лежащих на одной прямой: X1, Y1, X2, Y2, X3, Y3. Все числа целые, по модулю не превосходят 1000.\r\n\r\nФормат вывода\r\nВыведите два числа X и Y, задающие координаты точки пересечения биссектрис в треугольнике, образованном исходными точками, с точностью не менее 5 знаков после десятичной точки.','Найти точку пересечения биссектрис','Биссектриса делит противоположную сторону в известном отношении (можно найти из площади треугольника). По ним можно построить уравнение прямой и пересечь две прямые.','ЯК 12972 G4',''),(98,'Точка пересечения высот',14,'Дан невырожденный треугольник. Найти координаты точки пересечения высот.\r\n\r\nФормат ввода\r\nВход содержит координаты трех точек, не лежащих на одной прямой: X1, Y1, X2, Y2, X3, Y3. Все числа целые, по модулю не превосходят 10000.\r\n\r\nФормат вывода\r\nВыведите два числа X и Y, задающие координаты точки пересечения высот в треугольнике, образованном исходными точками, с точностью не менее 5 знаков после десятичной точки.','Найти точку пересечения высот','Опустим перпендикуляры из вершины на противоположные стороны, пересечем получившиеся прямые','ЯК 12972 H4',''),(99,'Треугольник и точка',13,'В декартовой системе координат на плоскости заданы координаты вершин треугольника и ещё одной точки. Определить, принадлежит ли эта точка треугольнику.\r\n\r\nФормат ввода\r\nВ четырёх строках находятся пары чисел — координаты точек. Числа в первых трёх строках — это координаты вершин треугольника, в четвёртой строке — координаты тестируемой точки. Координаты вершин — целые числа, для любой точки выполняются следующие условия: -104 ≤ x, y ≤ 104.\r\n\r\nФормат вывода\r\nВывести слово “In”, если точка находится внутри или на границе треугольника, или “Out” - если снаружи.','Проверить, принадлежит ли точка треугольнику','Можно проверить принадлежность точки многоугольнику, либо принадлежность точки каждому из трёх углов треугольника','ЯК 12972 I4',''),(100,'Точка и многоугольник',16,'Даны точка и многоугольник. Нужно проверить, находится ли эта точка внутри многоугольника.\r\n\r\nФормат ввода\r\nВ первой строке находятся три целых числа — количество вершин многоугольника N ( и координаты точки на плоскости. В последующих N строках содержатся пары чисел — координаты вершин многоугольника в порядке обхода. Все координаты целые и по модулю не превышают 104.\r\n\r\nФормат вывода\r\nВывести “YES”, если точка находится внутри, и “NO” — в противном случае.','Проверить, принадлежит ли точка многоугольнику','Можно кинуть горизонтальную или случайную прямую и проверить, что она пересекает многоугольник в нечетном количество мест.\r\n\r\nЛибо посчитать ориентированную сумму углов от точки до отрезков.','ЯК 12972 J4',''),(101,'Пусти козла в огород',30,'В огород пустили двух козлов, каждого привязав верёвкой к своему колышку. Каждый козёл движется по окружности, растягивая верёвку на максимальную длину. Найдите все точки, в которых они могут встретиться.\r\n\r\nФормат ввода\r\nВ первых двух строках находятся по три числа  — координаты колышка, к которому привязан каждый козёл, и длина верёвки, которой он привязан. Все числа — целые, не превосходящие по модулю 10000, длины веревок — положительные.\r\n\r\nФормат вывода\r\nВ первой строке выходного файла выведите количество точек пересечения (0, 1, 2 или 3, если их количество бесконечно). В случае одной точки пересечения выведите во второй строке координаты этой точки. В случае двух точек пересечения выведите координаты двух точек в лексикографическом порядке (то есть, сначала выведите ту точку, у которой меньше координата x, а если координаты x равны, то ту точку, у которой меньше координата y). Все числа следует выводить с точностью не менее 6 знаков после запятой.','Найти точку пересечения двух окружностей','Можно выписать уравнение и получить радикальную ось. Можно как-то через повороты линии центров.','ЯК 12972 K4',''),(102,'Связность',10,'В этой задаче требуется проверить, что граф является связным, то есть что из любой вершины можно по рёбрам этого графа попасть в любую другую. В графе могут существовать петли и кратные ребра.\r\nФормат ввода\r\nВ первой строке входного файла заданы числа \r\nN\r\n и \r\nM\r\n через пробел — количество вершин и рёбер в графе, соответственно (\r\n1\r\n≤\r\nN\r\n≤\r\n1\r\n0\r\n0\r\n, \r\n0\r\n≤\r\nM\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n). Следующие \r\nM\r\n строк содержат по два числа \r\nu\r\ni\r\n и \r\nv\r\ni\r\n через пробел (\r\n1\r\n≤\r\nu\r\ni\r\n,\r\nv\r\ni\r\n≤\r\nN\r\n); каждая такая строка означает, что в графе существует ребро между вершинами \r\nu\r\ni\r\n и \r\nv\r\ni\r\n.\r\nФормат вывода\r\nВыведите “YES”, если граф является связным, и “NO” в противном случае.','Проверить граф на связность','Запускаем обход графа, если обошли не все, то не связный','ЯК 12972 A5',''),(103,'Компоненты связности',11,'Вам задан неориентированный граф с \r\nN\r\n вершинами и \r\nM\r\n ребрами (\r\n1\r\n≤\r\nN\r\n≤\r\n2\r\n0\r\n0\r\n0\r\n0\r\n,\r\n1\r\n≤\r\nM\r\n≤\r\n2\r\n0\r\n0\r\n0\r\n0\r\n0\r\n). В графе отсутствуют петли и кратные ребра.\r\nОпределите компоненты связности заданного графа.\r\n\r\nФормат ввода\r\nГраф задан во входном файле следующим образом: первая строка содержит числа \r\nN\r\n и \r\nM\r\n. Каждая из следующих \r\nM\r\n строк содержит описание ребра — два целых числа из диапазона от \r\n1\r\n до \r\nN\r\n — номера концов ребра.\r\nФормат вывода\r\nНа первой строке выходного файла выведите число \r\nL\r\n — количество компонент связности заданного графа. На следующей строке выведите \r\nN\r\n чисел из диапазона от \r\n1\r\n до \r\nL\r\n — номера компонент связности, которым принадлежат соответствующие вершины. Компоненты связности следует занумеровать от \r\n1\r\n до \r\nL\r\n произвольным образом.','Разбить граф на компоненты связности','Запускаем обход графа из каждой еще не обойденной вершины','ЯК 12972 B5',''),(104,'Пошаговый обход графа',12,'Пошаговым обходом графа из вершины v назовём последовательность вершин u1,   u2,   …,   ur такую, что:\r\n\r\n u1 = ur = v,\r\n\r\n Каждая вершина графа, достижимая из v, встречается в ней хотя бы один раз, и\r\n\r\n Между любыми двумя соседними вершинами последовательности в графе существует ребро. Задан связный неориентированный граф и его вершина v. Выведите любой пошаговый обход этого графа.\r\n\r\nФормат ввода\r\nВ первой строке входного файла заданы числа N, M и v через пробел — количество вершин и рёбер в графе и начальная вершина обхода (, , ). Следующие M строк содержат по два числа ui и vi через пробел (); каждая такая строка означает, что в графе существует ребро между вершинами ui и vi.\r\n\r\nФормат вывода\r\nВ первой строке входного файла выведите число r — количество вершин в найденном пошаговом обходе (; гарантируется, что обход, удовлетворяющий этим ограничениям, существует). Во второй строке выведите сами числа u1,   u2,   …,   ur через пробел.\r\n\r\n','Вывести, в каком порядке мы будем ходить по вершинам, если запустим обход в глубину.','Запустим обход в глубину и посмотрим, что получится','ЯК 12972 C5',''),(105,'Поиск цикла',19,'Дан ориентированный невзвешенный граф без кратных рёбер. Необходимо определить, есть ли в нём циклы, и если есть, то вывести любой из них.\r\n\r\nФормат ввода\r\nВ первой строке входного файла находятся два натуральных числа N и M (, ) — количества вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами начальной и конечной вершин.\r\n\r\nФормат вывода\r\nЕсли в графе нет цикла, то вывести «NO», иначе — «YES» и затем перечислить все вершины в порядке обхода цикла.','Найти цикл в ориентированном графе','Будем красить вершины в три цвета - не посещенная, обрабатываемая и обработанная','ЯК 12972 D5',''),(106,'TopSort',16,'Дан ориентированный невзвешенный граф. Необходимо его топологически отсортировать.\r\n\r\nФормат ввода\r\nВ первой строке входного файла два натуральных числа N и M () — количество вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задается парой чисел — номерами начальной и конечной вершин соответственно.\r\n\r\nФормат вывода\r\nВывести любую топологическую сортировку графа в виде последовательности номеров вершин. Если граф невозможно топологически отсортировать, вывести -1.','Найти топологическую сортировку','Проверим граф на цикличность. Если цикла нет, то запустим dfs и будем записывать вершину в ответ, когда мы ее обошли.','ЯК 12972 E5',''),(107,'Island. Островные государства',23,'Суровые феодальные времена переживала некогда великая островная страна Байтландия. За главенство над всем островом борются два самых сильных барона. Таким образом, каждый город страны контролируется одним из правителей. Как водится издревле, некоторые из городов соединены двусторонними дорогами. Бароны очень не любят друг друга и стараются делать как можно больше пакостей. В частности, теперь для того чтобы пройти по дороге, соединяющей города различных правителей, надо заплатить пошлину — один байтландский рубль.\r\nПрограммист Вася живет в городе номер \r\n1\r\n. С наступлением лета он собирается съездить в город \r\nN\r\n на Всебайтландское сборище программистов. Разумеется, он хочет затратить при этом как можно меньше денег и помочь ему здесь, как обычно, предлагается Вам.\r\n\r\nФормат ввода\r\nВ первой строке входного файла записано два числа \r\nN\r\n и \r\nM\r\n (\r\n1\r\n≤\r\nN\r\n,\r\nM\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\n) — количество городов и количество дорог соответсвенно.\r\nВ следующий строке содержится информация о городах — \r\nN\r\n чисел \r\n1\r\n или \r\n2\r\n — какому из баронов принадлежит соответствующий город.\r\nВ последних \r\nM\r\n строках записаны пары \r\n1\r\n≤\r\na\r\n,\r\nb\r\n≤\r\nN\r\n, \r\na\r\n≠\r\nb\r\n. Каждая пара означает наличие дороги из города \r\na\r\n в город \r\nb\r\n. По дорогам Байтландии можно двигаться в любом направлении.\r\n\r\nФормат вывода\r\nЕсли искомого пути не существует, выведите единственное слово impossible. В противном случае в первой строке напишите минимальную стоимость и количество посещенных городов, а во вторую выведите эти города в порядке посещения. Если минимальных путей несколько, выведите любой.\r\n','Дан граф, разбитый на две части. Стоимость ребра между частями 1, внутри частей 0. Найти кратчайший путь.','0-1 bfs. Либо дейкстра','ЯК 12972 A6','В этой задаче заходит решение с простым обходом в ширину. Существует тест, на котором оно будет работать за квадрат.'),(108,'Расстояние от корня',14,'В заданном корневом дереве найдите вершины, максимально удалённые от корня. Расстоянием между вершинами считается количество рёбер в пути.\r\nФормат ввода\r\nВ первой строке задано \r\nn\r\n — количество вершин в дереве (\r\n1\r\n≤\r\nn\r\n≤\r\n1\r\n0\r\n0\r\n). В следующих \r\nn\r\n−\r\n1\r\nстроках заданы вершины, являющиеся предками вершин \r\n2\r\n, \r\n3\r\n, \r\n…\r\n, \r\nn\r\n. Вершина \r\n1\r\n является корнем дерева.\r\nФормат вывода\r\nВ первой строке выведите максимальное расстояние от корня до остальных вершин дерева. Во второй строке выведите, сколько вершин дерева находятся от корня на таком расстоянии. В третьей строке выведите номера этих вершин через пробел в порядке возрастания.','Найти все вершины максимально удаленные от корня.','Запустим bfs, выведем все вершины, для которых расстояние максимально.','ЯК 12972 B6',''),(109,'Волновой обход графа',16,'Пусть расстояние от вершины \r\nu\r\n до вершины \r\nv\r\n — это минимальное количество рёбер в пути между \r\nu\r\n и \r\nv\r\n; так, расстояние между \r\nu\r\n и \r\nu\r\n — \r\n0\r\n, а расстояние между любыми двумя различными соседними вершинами — \r\n1\r\n.\r\nВолновым обходом графа из вершины \r\nv\r\n назовём последовательность вершин \r\nu\r\n1\r\n,\r\nu\r\n2\r\n,\r\n…\r\n,\r\nu\r\nr\r\n такую, что:\r\n\r\nu\r\n1\r\n=\r\nv\r\n,\r\nКаждая вершина графа, достижимая из \r\nv\r\n, встречается в ней хотя бы один раз, и\r\nКаждая следующая вершина последовательности удалена от вершины \r\nv\r\n не меньше, чем предыдущая.\r\nЗадан связный неориентированный граф и его вершина \r\nv\r\n. Выведите любой волновой обход этого графа.\r\n\r\nФормат ввода\r\nВ первой строке входного файла заданы числа \r\nN\r\n, \r\nM\r\n и \r\nv\r\n через пробел — количество вершин и рёбер в графе и начальная вершина обхода (\r\n1\r\n≤\r\nN\r\n≤\r\n1\r\n0\r\n0\r\n, \r\n0\r\n≤\r\nM\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n, \r\n1\r\n≤\r\nv\r\n≤\r\nN\r\n). Следующие \r\nM\r\n строк содержат по два числа \r\nu\r\ni\r\n и \r\nv\r\ni\r\n через пробел (\r\n1\r\n≤\r\nu\r\ni\r\n,\r\nv\r\ni\r\n≤\r\nN\r\n); каждая такая строка означает, что в графе существует ребро между вершинами \r\nu\r\ni\r\n и \r\nv\r\ni\r\n.\r\nФормат вывода\r\nВ первой строке входного файла выведите число \r\nr\r\n — количество вершин в найденном волновом обходе (\r\n1\r\n≤\r\nr\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n; гарантируется, что обход, удовлетворяющий этим ограничениям, существует). Во второй строке выведите сами числа \r\nu\r\n1\r\n,\r\nu\r\n2\r\n,\r\n…\r\n,\r\nu\r\nr\r\n через пробел.','Выписать вершины в порядке обхода в ширину.','Запустим обход в ширину, и выпишем его.','ЯК 12972 C6',''),(110,'Выход из лабиринта',15,'Во время торнадо в Костромской области было повалено большое количество деревьев. Однажды утром, спустя пару дней после торнадо, мальчик Илья вышел прогуляться и увидел, что поваленные деревья образовали настоящий лабиринт. Вася очень обрадовался, стал гулять и играть в лабиринте. Внезапно ему позвонил преподаватель и поинтересовался, почему он давно не видел Илью. Чтобы не получить дырку в бэйджик за самовольный выход за территорию лагеря, Илья, конечно же, хотел попасть в домик как можно скорее, но и побродить по лабиринту ему тоже очень хотелось. Помогите ему узнать, как быстро он сможет добраться до домика.\r\n\r\nФормат ввода\r\nВ первой строке входного файла заданы целые положительные числа N и M (). В следующих N строках заданы по M символов, описывающих лабиринт. На позициях, по которым Илья может перемещаться, записан символ «0», а на позициях, которые перегорожены деревьями, записан символ «1». После описания лабиринта следуют целые числа x1, y1, x2, y2 — координаты (то есть соответствующие номера столбцов и строк) Ильи и его домика соответственно (, ).\r\n\r\nФормат вывода\r\nВ выходной файл выведите единственное число — длину кратчайшего пути от точки (x1, y1) до точки (x2, y2), если Илья может добраться до дому по лабиринту, и «-1» в противном случае.\r\n\r\n','Дана таблица, некоторые клетки непроходимы. Из одной прийти в другую за минимальное количество шагов.','Обход в ширину на графе-таблице','ЯК 12972 D6',''),(111,'Дейкстра',25,'Дан ориентированный взвешенный граф.\r\n\r\nНайдите кратчайшее расстояние от одной заданной вершины до другой.\r\n\r\nФормат ввода\r\nВ первой строке входного файла три числа: N, S и F (), где N — количество вершин графа, S — начальная вершина, а F — конечная. В следующих N строках по N чисел — матрица смежности графа, где -1 означает отсутствие ребра между вершинами, а любое целое неотрицательное число, не превосходящее 10 000 — присутствие ребра данного веса. На главной диагонали матрицы всегда нули.\r\n\r\nФормат вывода\r\nВывести искомое расстояние или -1, если пути не существует.','Найти кратчайшее расстояние в ориентированном взвешенном графе','Тут по идее заработает только квадратная дейкстра.','ЯК 12972 E6',''),(112,'Расстояние между вершинами',26,'Дан неориентированный взвешенный граф. Требуется найти вес минимального пути между двумя вершинами.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит два натуральных числа n и m — количества вершин и рёбер графа соответственно (, ). Вторая строка входного файла содержит натуральные числа s и t — номера вершин, длину пути между которыми требуется найти (, s ≠ t).\r\n\r\nСледующие m строк содержат описание рёбер по одному на строке. Ребро номер i описывается тремя натуральными числами bi, ei и wi — номерами концов ребра и его вес соответственно (, ).\r\n\r\nФормат вывода\r\nПервая строка выходного файла должна содержать одно натуральное число — вес минимального пути между вершинами s и t. Если пути не существует, выведите -1\r\n\r\n','Найти кратчайшее расстояние в неориентированном графе','Здесь нужна дейкстра с сетом','ЯК 12972 F6',''),(113,'Bad Roads',40,'В Байтландии есть некоторое количество городов, соединённых дорогами с односторонним движением. К сожалению, состояние дорог оставляет желать лучшего, так что некоторые дороги являются непроходимыми для некоторых автомобилей. Более точно, для каждой дороги известен параметр — минимальная высота просвета для автомобиля, который может проехать по этой дороге.\r\n\r\nНекоторые дороги являются платными. Плата за проезд такой дороги равна одному байтландскому тугрику. Также для каждой дороги известно время, которое автомобиль должен потратить, чтобы проехать эту дорогу.\r\n\r\nТребуется найти, какая минимальная высота просвета может быть у автомобиля, на котором можно проехать из города s в город f не более, чем за t минут, потратив при этом не более m байтландских тугриков.\r\n\r\nФормат ввода\r\nПервая строка входных данных содержит четыре целых числа: количество городов n (1 ≤ n ≤ 100), количество дорог m (1 ≤ m ≤ 104), номер стартового города s и финишного города f (1 ≤ s, t ≤ n). Вторая строка содержит два целых числа — максимальную сумму денег, которую можно потратить m (0 ≤ m ≤ 106) и максимальное время на дорогу (0 ≤ t ≤ 106). Каждая из последующих m строк имеет формат ui, vi, ci, ti и hi, где ui — город, в котором дорога начинается, vi — город, в котором дорога заканчивается, ci=1, если дорога платная, и ci=0 в противном случае, ti — это время, которое требуется для того, чтобы проехать по этой дороге, а hi — минимальный дорожный просвет, требуемый для того, чтобы проехать по этой дороге (1 ≤ ui, vi ≤ n, 0 ≤ ti ≤ 104 и 0 ≤ hi ≤ 106). Все числа во входных данных целые.\r\n\r\nФормат вывода\r\nЕсли проехать из s в f, уложившись в ограничения по расходам и по времени, невозможно, выведите -1. Иначе в первой строке выведите минимальную высоту дорожного просвета автомобиля, при которой можно уложиться в ограничения, во второй — количество дорог в каком-либо маршруте, удовлетворяющем ограничениям, а в третьей — номера использованных дорог, перечисленные в порядке прохождения маршрута. Дороги занумерованы последовательными целыми числами от 1 до m в том порядке, в котором они заданы во входных данных.','Дан ориентированный граф. У каждого ребра три параметра - минимальная высота просвета, стоимость(0 или 1) и время проезда. Надо потратить не более t минут, не более m монет и проехать с как можно меньшим просветом.','Запустим Форда-Беллмана с запоминанием количества пройденных дорог, на нем построим динамику с ответом.','ЯК 12972 G6',''),(114,'Cyrrency Exchange',63,'В городе работает несколько пунктов обмена валюты. Предположим, что каждый пункт производит обмен только между двумя валютами; причём может существовать более, чем один обменный пункт, работающий с одной и той же парой валют. В каждом обменном пункте свои курсы; курс валюты A к валюте B — это количество валюты B, которое вы получаете за одну единицу валюты A. Также в каждом обменном пункте установлена комиссия — сумма, который вы платите за операцию обмена. Комиссия всегда взымается в валюте, которая обменивается.\r\n\r\nНапример, если вы планируете обменять 100 байтландских тугриков на берляндские бурли в обменном пункте, в котором курс равен 29.75, а комиссия равна 0.39, вы получите (100-0.39) ⋅ 29.75 = 2963.3975 берляндских бурлей.\r\n\r\nВсего в городе работают с N валютами. Присвоим каждой валюте номер от 1 до N. Тогда каждый обменный пункт может быть описан 6 числами: целые числа A и B — номера валют, с которыми он работает и вещественные числа RAB, CAB, RBA и CBA – обменные курсы и комиссия при обмене A на B и B на A соответственно.\r\n\r\nУ лося Валеры есть некоторая сумма в валюте S и он интересуется, может ли он провести несколько обменных операций и в итоге увеличить свой капитал (оставшись при этом в валюте S).\r\n\r\nПомогите ему ответить на его вопрос. Заметим, что в минус лось уходить не может.\r\n\r\nФормат ввода\r\nПервая строка входных данных содержат четыре целых числа: N – общее количество валют, M – количество обменных пунктов, S – тип валюты, которая есть у лося Валеры и V – количество этой валюты. Каждая из последующих M строк содержит по 6 целых чисел — описание соответствующего пункта обмена в указанном выше порядке. Числа разделены одним или несколькими пробелами. 1 ≤ S ≤ N ≤ 100, 1 ≤ M ≤ 100, V — вещественное число, 0 ≤ V ≤ 103.\r\n\r\nДля каждого обменного пункта курсы обмена и комиссия вещественны и заданы не более, чем с двумя знаками после десятичной точки. 10-2 ≤ rate ≤ 102, 0 ≤ commission ≤ 102.\r\n\r\nНазовём последовательность обменных операций простой, если ни один обменный пункт не используется в этой последовательности дважды. Гарантируется, что отношение численных значений денежных сумм в начале и в конце каждой последовательности обменных операций не превосходит 104.\r\n\r\nФормат вывода\r\nЕсли лось может увеличить свой капитал, выведите “YES”. Иначе выведите “NO”.','Есть много валют. Их можно между собой обменивать с разными курсами и комиссией. Необходимо провести несколько обменов и остаться в плюсе.','Каждый пункт обмена - это ребро. В таком графе надо найти положительный цикл. Это можно сделать алгоритмом Форда-Беллмана.','ЯК 12972 A7','В этой задаче нет сэмплов - надо добавить'),(115,'Диаметр графа',34,'Дан связный взвешенный неориентированный граф.\r\nРассмотрим пару вершин, расстояние между которыми максимально среди всех пар вершин. Расстояние между ними называется диаметром графа. Эксцентриситетом вершины v называется максимальное расстояние от вершины v до других вершин графа. Радиусом графа называется наименьший из эксцентриситетов вершин. Найдите диаметр и радиус графа.\r\n\r\nФормат ввода\r\nВ первой строке входного файла единственное число: \r\nN\r\n (\r\n1\r\n≤\r\nN\r\n≤\r\n1\r\n0\r\n0\r\n) — количество вершин графа. В следующих \r\nN\r\n строках по \r\nN\r\n чисел — матрица смежности графа, где -1 означает отсутствие ребра между вершинами, а любое неотрицательное число — присутствие ребра данного веса. На главной диагонали матрицы всегда нули; веса рёбер не превышают 1000.\r\nФормат вывода\r\nВ выходной файл выведите два числа — диаметр и радиус графа.','Найти радиус и диаметр взвешенного графа.','Запустим алгоритм Флойда. Затем переберем пары вершин и найдем ответ.','ЯК 12972 B7',''),(116,'Флойд',24,'Полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его вершинами.\r\n\r\nГарантируется, что в графе нет циклов отрицательного веса.\r\n\r\nФормат ввода\r\nВ первой строке вводится единственное число N () — количество вершин графа. В следующих N строках по N чисел задается матрица смежности графа (j-ое число в i-ой строке — вес ребра из вершины i в вершину j). Все числа по модулю не превышают 100. На главной диагонали матрицы — всегда нули.\r\n\r\nФормат вывода\r\nВыведите N строк по N чисел — матрицу расстояний между парами вершин, где j-ое число в i-ой строке равно весу кратчайшего пути из вершины i в j.\r\n\r\n','Построить матрицу кратчайших расстояний','Запустим алгоритм Флойда','ЯК 12972 C7',''),(117,'Лабиринт знаний',30,'Участникам сборов подарили билеты на аттракцион “Лабиринт знаний”. Лабиринт представляет собой N комнат, занумерованных от 1 до N, между некоторыми из которых есть двери. Когда человек проходит через дверь, показатель его знаний изменяется на определенную величину, фиксированную для данной двери. Вход в лабиринт находится в комнате 1, выход — в комнате N. Каждый участник сборов проходит лабиринт ровно один раз и набирает некоторое количество знаний (при входе в лабиринт этот показатель равен нулю). Ваша задача — показать наилучший результат.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит целые числа N (1≤ N≤ 2 000) — количество комнат и M (0≤ M≤ 10 000) — количество дверей. В каждой из следующих M строк содержится описание двери — номера комнат, из которой она ведет и в которую она ведет (через дверь в лабиринте можно ходить только в одну сторону), а также целое число, которое прибавляется к количеству знаний при прохождении через дверь (это число по модулю не превышает 10 000). Двери могут вести из комнаты в нее саму, между двумя комнатами может быть более одной двери.\r\n\r\nФормат вывода\r\nВ выходной файл выведите “:)” — если можно пройти лабиринт и получить неограниченно большой запас знаний, “:(” — если лабиринт пройти нельзя, и максимальное количество набранных знаний в противном случае.\r\n\r\n','Дан граф, найти путь максимального веса','Запустим алгоритм Форда-Беллмана и проверим, что нет положительных циклов','ЯК 12972 D7',''),(118,'Порядок циклов',17,'Дан неориентированный граф из \r\nn\r\n вершин, заданный матрицей смежности a (a[u][u] = True; a[u][v] = a[v][u]; a[u][v] = True тогда и только тогда, когда есть ребро между вершинами u и v). На нём запускают следующий алгоритм:\r\nfor x := 1 to n do  \r\n  for y := 1 to n do  \r\n    for z := 1 to n do  \r\n      if a[i][k] and a[k][j] then  \r\n        a[i][j] := True;\r\nПеред запуском буквы x, y и z заменяют буквами i, j и k в некотором порядке. Утверждается, что после работы этого алгоритма a[u][v] = True тогда и только тогда, когда в исходном графе существует путь между вершинами u и v. Выясните, верно ли это, и если нет, приведите пример исходного графа, на котором это неверно.\r\n\r\nФормат ввода\r\nВ первой строке входного файла записаны через пробел три буквы — ‘i’, ‘j’ и ‘k’ — в некотором порядке. Первая буква подставляется в программу вместо ‘x’, вторая — вместо ‘y’, третья — вместо ‘z’.\r\nФормат вывода\r\nЕсли искомый граф существует, в первой строке выходного файла выведите через пробел целые числа \r\nn\r\n и \r\nm\r\n — количество вершин и рёбер в графе, соответственно (\r\n1\r\n≤\r\nn\r\n≤\r\n1\r\n0\r\n, \r\n0\r\n≤\r\nm\r\n≤\r\n4\r\n5\r\n). В следующих \r\nm\r\n строках выведите пары вершин, соединённых рёбрами, по одной паре на строке. Номера вершин в паре должны быть упорядочены по возрастанию; вершины нумеруются с единицы. Кратные рёбра и петли не допускаются.\r\nЕсли же программа с заданным порядком циклов корректно работает на любом графе, вместо \r\nn\r\n и \r\nm\r\n выведите в первой строке два нуля через пробел.','Привести пример графа, на котором алгоритм Флойда с неправильным порядком циклов не будет работать','Кажется, что подойдёт почти любой большой граф. Но можно построить руками','ЯК 12972 E7',''),(119,'Path. Кратчайший путь',30,'Дан взвешенный ориентированный граф и вершина \r\ns\r\n в нем. Требуется для каждой вершины \r\nu\r\nнайти длину кратчайшего пути из \r\ns\r\n в \r\nu\r\n.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит \r\nn\r\n, \r\nm\r\n и \r\ns\r\n — количество вершин, ребер и номер выделенной вершины соответственно (\r\n2\r\n≤\r\nn\r\n≤\r\n2\r\n0\r\n0\r\n0\r\n, \r\n1\r\n≤\r\nm\r\n≤\r\n6\r\n0\r\n0\r\n0\r\n).\r\nСледующие \r\nm\r\n строк содержат описание ребер. Каждое ребро задается стартовой вершиной, конечной вершиной и весом ребра. Вес каждого ребра — целое число, не превосходящее \r\n1\r\n0\r\n1\r\n5\r\nпо модулю. В графе могут быть кратные ребра и петли.\r\n\r\nФормат вывода\r\nВыведите \r\nn\r\n строк — для каждой вершины \r\nu\r\n выведите длину кратчайшего пути из \r\ns\r\n в \r\nu\r\n, ‘*’ если не существует путь из \r\ns\r\n в \r\nu\r\n и ‘-’ если не существует кратчайший путь из \r\ns\r\n в \r\nu\r\n.','Найти длину кратчайшего пути от одной вершины до всех остальных','Запустим алгоритм Форд-Беллмана и выведем ответ','ЯК 12972 F7',''),(120,'Окружность и прямая',19,'Даны окружность и прямая. Найти все точки их пересечения.\r\n\r\nФормат ввода\r\nШесть целых чисел — координаты центра Xi и Yi, радиус окружности Ri и коэффициенты A, B и C уравнения прямой (0 ≤ Ri ≤ 104, все координаты не превосходят 104 по абсолютной величине).\r\n\r\nФормат вывода\r\nВ первой строке одно число K, равное количеству точек пересечения прямой с окружностью. Далее в K строках координаты самих точек с точностью не хуже 10-3.','Найти точки пересечения двух окружностей','Можно опустить перпендикуляр и от него пойти вдоль прямой на нужное расстояние','ЯК 12973 B1',''),(121,'Две окружности',22,'Вам даны две окружности в плоскости. Найдите все их различные точки пересечения.\r\n\r\nФормат ввода\r\nВ первой строке следует целое число M (1 ≤ M ≤ 10 000) — количество тестов.\r\n\r\nСледующие 2 ⋅ M строк описывают сами окружности. Каждая окружность описывается тремя целыми числами: координатами центра и радиусом.\r\n\r\nГарантируется, что все координаты от -1 000 до 1 000, а все радиусы окружностей положительны и не превосходят 1 000.\r\n\r\nФормат вывода\r\nДля каждого теста выведите следующее.\r\n\r\nЕсли у окружностей нет точек пересечения, выведите 0.\r\n\r\nЕсли у окружностей бесконечное количество точек пересечения, выведите -1.\r\n\r\nЕсли у окружностей есть точки пересечения и их количество конечно, выведите целое число k — количество точек пересечения, а в следующие k строк выведите сами точки пересечения, сортируя их по x в первую очередь и по y во вторую. Абсолютная или относительная погрешность выведенных точек пересечения не должна превышать 10-8.\r\n\r\nРазделяйте выводы для разных тестов пустой строкой.','Найти точки пересечений двух окружностей','Можно с помощью радикальной оси, можно поворачивая линию центров на нужный угол','ЯК 12973 C1',''),(122,'Жадный король',20,'Жил-был жадный король, который однажды приказал главному архитектору окружить королевский замок стеной. Король был настолько жаден, что не желал слушать рассказы архитектора о красивой кирпичной стене с прекрасным силуэтом и изящными высокими башнями. Вместо этого он приказал окружить замок стеной, затратив минимальное количество камня и времени, но потребовал, чтобы стена не подходила к замку ближе, чем на заданное расстоние. Если король узнает, что архитектор потратил не минимально возможное количество ресурсов, то архитектор лишится головы. Более того, король потребовал, чтобы архитектор сразу же предложил проект стены с указанием минимального количества ресурсов, необходимых для постройки.\r\n\r\nВы должны помочь архитектору сохранить голову, написав программу для поиска минимальной длины стены, удовлетворяющей условиям короля.\r\n\r\nЗадачу упрощает то, что замок короля имеет форму многоугольника и расположен на равнине. Архитектор уже ввел систему координат и точно измерил координаты вершин замка в футах.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит числа N и L, разделенные пробелом. N () — это количество вершин в королевском замке, а L () — минимальное количество футов, на которое стена может приближаться к замку.\r\n\r\nСледующие N строк описывают координаты замка в порядке обхода по часовой стрелке. В каждой строке через пробел записаны целые числа xi и yi, разделенные пробелом (), которые обозначают координаты i-ой вершины. Все вершины различны, и никакие две стороны не пересекаются кроме как по вершинам.\r\n\r\nФормат вывода\r\nВыведите минимальную длину стены в футах, удовлетворяющей условиям короля с точностью не менее 6 знаков после запятой.\r\n\r\n','Найти длину стены, которая достаточно далеко от данных точек','Построим выпуклую оболочку. Ответ - ее периметр + длина окружности с радиусом = расстояние','ЯК 12973 E1',''),(123,'Выпуклая оболочка',19,'Дано N точек на плоскости. Нужно построить их выпуклую оболочку. Гарантируется, что выпуклая оболочка является невырожденной.\r\n\r\nФормат ввода\r\nВ первой строке число N (3 ≤ N ≤ 105). Следующие N строк содержат пары целых чисел x и y (-109 ≤ x, y ≤ 109) – координаты точек.\r\n\r\nФормат вывода\r\nВ первой строке выведите N – число вершин выпуклой оболочки. Следующие N строк должны содержать координаты вершин в порядке обхода. Никакие три подряд идущие точки не должны лежать на одной прямой.','Построить выпуклую оболочку','Применяем алгоритм Грэхема или Джарвиса или Эндрю','ЯК 12973 F1',''),(124,'Теодор Рузвельт',24,'«Теодор Рузвельт» — флагман военно-морского флота Кукуляндии. Заклятые враги кукуляндцев, флатландцы, решили уничтожить его. Они узнали, что «Теодор Рузвельт» представляет собой выпуклый многоугольник из n вершин и узнали его координаты. Затем они выпустили m баллистических ракет и определили координаты точек, где эти ракеты взорвались. По расчетам штаба флатландцев, «Теодор Рузвельт»будет уничтожен, если в него попадёт хотя бы k ракет. Вычислите, удалось ли флатландцам уничтожить корабль.\r\n\r\nФормат ввода\r\nВ первой строке через пробел записаны целые числа n, m, k (, ). В последующих n строках записаны координаты вершин многоугольника в порядке обхода против часовой стрелке. В следующих m строках записаны координаты точек. Гарантируется, что все координаты — целые числа, не превосходящие по модулю 109.\r\n\r\nФормат вывода\r\nВыведите YES, если в многоугольнике лежит по крайней мере k точек, и NO в противном случае.','Много раз проверить, принадлежит ли точка выпуклому многоугольнику','Бинарным поиском ищем треугольник, в котором может находиться очередная точка','ЯК 12973 G1',''),(125,'Внутри или вовне?',26,'Несколько выпуклых многоугольников вложены друг в друга так, что второй многоугольник помещён в первый, третий — во второй и так далее. Каждый следующий многоугольник лежит строго внутри предыдущего (то есть контуры многоугольников не имеют общих точек). После этого стороны многоугольников стираются и остаётся только набор вершин.\r\n\r\nВаша задача — восстановить всю конструкцию, то есть для каждой вершины сообщить номер многоугольника, которому она принадлежит. Отметим, что точка и отрезок являются выпуклыми многоугольникам с 1 и 2 сторонами соответственно.\r\n\r\nФормат ввода\r\nПервая строка входа содержит одно целое число N (1 \r\n N \r\n 2 ⋅ 104) — количество вершин. В i-й из последующих N строк заданы два целых числа xi и yi — координаты i-й точки. Координаты не превосходят 104 по абсолютной величине.\r\n\r\nФормат вывода\r\nВыведите N строк, по одной на каждую вершину. Каждая строка должна содержать одно целое число — номер выпуклого многоугольника для данной вершины (многоугольники занумерованы так, что внешний имеет номер 1, лежащий непосредственно в нём — номер 2 и так далее).','Разбить данные точки на систему вложенных выпуклых многоугольников','Запускаем много раз алгоритм заворачивания подарка.','ЯК 12973 H1',''),(126,'Сеть',46,'В компьютерной сети вашей фирмы \r\nn\r\n компьютеров. В последнее время свитч, к которому они подключены, сильно барахлит, и потому не любые два компьютера могут связаться друг с другом. Кроме того, если компьютер  \r\na\r\n обменивается информацией с компьютером  \r\nb\r\n, то никакие другие компьютеры не могут в это время обмениваться информацией ни с  \r\na\r\n, ни c  \r\nb\r\n. Вам необходимо вычислить максимальное количество компьютеров, которые могут одновременно участвовать в процессе обмена информацией.\r\nФормат ввода\r\nВ первой строке файла задано число \r\nn\r\n ( \r\n1\r\n≤\r\nn\r\n≤\r\n1\r\n8\r\n). Далее идут \r\nn\r\n строк по  \r\nn\r\n символов, причём \r\nj\r\n-й символ \r\ni\r\n-й строки равен ‘ Y’, если \r\ni\r\n-й и  \r\nj\r\n-й компьютеры могут обмениваться информацией, иначе он равен ‘ N’. Верно, что \r\ni\r\n-й символ \r\ni\r\n-й строки всегда равен ‘ N’ и, кроме того, матрица символов симметрична.\r\nФормат вывода\r\nВыведите максимальное количество компьютеров, которые могут одновременно участвовать в процессе обмена информацией.','Найти максимальное паросочетание в произвольном графе','ДП по подмножествам - dp[mask] - можно ли задействовать эту маску. Берем самую большую вошедшую вершину и перебираем ее возможных соседей.','ЯК 12973 A2',''),(127,'Назначения',49,'В группе учится N студентов. Требуется посчитать количество способов распределить N тем курсовых работ между ними так, чтобы каждому досталась тема, которая ему нравится.\r\n\r\nФормат ввода\r\nВ первой строке входного файла записано число N (). Далее следует N строк, описывающих предпочтения каждого студента, по N чисел в каждой. Если i -ая тема нравится студенту, i -ое число в строке равно 1, иначе оно равно 0.\r\n\r\nФормат вывода\r\nВ выходной файл выведите одно число – искомое количество способов.','Посчитать количество максимальных паросочетаний в двудольном графе','dp[i][mask] - использовали первых i студентов и задачи из маски. Храним количество способов.','ЯК 12973 B2',''),(128,'Деловые встречи',39,'Алексей — успешный предприниматель, и в течение одного дня у него бывает много встреч с разными деловыми партнёрами. К сожалению, встречи бывают разные и не все приносят ему радость, после других же настроение улучшается. Также, на многие встречи не стоит приходить в слишком плохом или хорошем настроении — результат таких встреч может быть не таким, какой хочется Алексею.\r\nК счастью, недавно Алексей научился оценивать своё настроение с помощью целых чисел. После этого для каждой встречи он оценил, при каком максимальном и минимальном настроении стоит на неё приходить, а также как изменится его настроение после этой встречи. Теперь он хочет распланировать порядок встреч так, чтобы в течение дня совершить максимальное число встреч.\r\nВаша задача — написать программу, которая по информации о всех встречах и настроении Алексея в начале дня находит порядок проведения встреч такой, что их количество при этом максимально.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит два целых числа \r\nn\r\n и \r\nk\r\n ( \r\n1\r\n≤\r\nn\r\n≤\r\n2\r\n0\r\n,\r\n−\r\n1\r\n0\r\n0\r\n≤\r\nk\r\n≤\r\n1\r\n0\r\n0\r\n) — количество встреч и настроение Алексея в начале дня.\r\nСледующие \r\nn\r\n строк содержат по три целых числа \r\na\r\ni\r\n, \r\nb\r\ni\r\n и \r\nc\r\ni\r\n ( \r\n−\r\n1\r\n0\r\n0\r\n≤\r\na\r\ni\r\n,\r\nb\r\ni\r\n,\r\nc\r\ni\r\n≤\r\n1\r\n0\r\n0\r\n) — минимальное и максимальное настроение, при котором встреча возможна, и изменение настроения по окончании встречи, соответственно.\r\n\r\nФормат вывода\r\nВ первой строке выходного файла выведите число \r\nm\r\n — максимально возможно число встреч. В следующей строке выведите \r\nm\r\n целых чисел — номера встреч в порядке их проведения. Встречи пронумерованы в порядке описания во входном файле.\r\nЕсли ответов с максимальным числом встреч несколько, выведите любой.','Есть настроение, есть встречи. На каждую встречу можно приходить с определенным диапазоном настроения, после встречи оно меняется. Найти максимальное количество встреч, которые можно посетить','Я предполагаю, что встречи нельзя переставлять местами, хотя в условии этого явно не написано.\r\n\r\ndp[mask] - можно ли добиться такой маски. Находим последнюю встречу и проверяем, что ее можно посетить','ЯК 12973 C2',''),(129,'Укладка плитки',41,'В процессе ремонта в Лаборатории Информационных Технологий строителям необходимо заменить поврежденные напольные плитки в коридоре лаборатории, который имеет размер 2 × n метров. В распоряжении строителей есть неограниченный запас плиток двух размеров: 1 × 2 метра и 1 × 1 метр. При этом плитки размером 1 × 2 метра перед укладкой разрешается поворачивать на 90 градусов и размещать как вдоль, так и поперек коридора.\r\n\r\nСтроители уже начали ремонт и уложили в некоторых местах пола коридора k плиток размером 1 × 1. Для завершения ремонта прорабу необходимо подготовить план дальнейших работ. Для этого ему надо решить, каким образом уложить плитки на места, где они еще не уложены. Это можно сделать различными способами и прораб хочет перебрать все варианты и выбрать самый удачный. Перед тем как это сделать, прораб хочет знать, какое количество вариантов ему придется рассмотреть. Это число требуется найти по модулю 109 + 7.\r\n\r\nТребуется написать программу, которая по заданной длине коридора n и расположению плиток, которые уже уложены, определяет количество способов укладки плиток на оставшиеся места. Ответ необходимо вывести по модулю 109 + 7.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит два целых числа: n – длину коридора и k – количество уже уложенных единичных плиток (, ).\r\n\r\nПоследующие k строк содержат по два целых числа xi и yi, которые задают позиции уже уложенных единичных плиток, i -я плитка уложена на xi -м метре коридора в yi -м ряду (, ).\r\n\r\nФормат вывода\r\nВыходной файл должен содержать одно целое число – количество способов укладки плиток в коридоре, взятое по модулю 109 + 7.','На полоске 2 \\times n некоторые клетки заняты. Есть плитки размера 1 \\times 1  и 1 \\times 2. Найти количество замощений','Поскольку ширина коридора 2, то можно не писать явно динамику по профилю (хотя она и будет таковой по факту), а просто динамику в которой хранить как занят последний столбец. Опять же, в силу ширины таблицы изломанный профиль тут не нужен.','ЯК 12973 D2',''),(130,'Симпатичные узоры',54,'Компания BrokenTiles планирует заняться выкладыванием во дворах у состоятельных клиентов узор из черных и белых плиток, каждая из которых имеет размер 1× 1 метр. Известно, что дворы всех состоятельных людей имеют наиболее модную на сегодня форму прямоугольника M× N метров.\r\n\r\nОднако при составлении финансового плана у директора этой организации появилось целых две серьезных проблемы: во первых, каждый новый клиент очевидно захочет, чтобы узор, выложенный у него во дворе, отличался от узоров всех остальных клиентов этой фирмы, а во вторых, этот узор должен быть симпатичным.\r\n\r\nКак показало исследование, узор является симпатичным, если в нем нигде не встречается квадрата 2 × 2 метра, полностью покрытого плитками одного цвета.\r\n\r\nДля составления финансового плана директору необходимо узнать, сколько клиентов он сможет обслужить, прежде чем симпатичные узоры данного размера закончатся. Помогите ему!\r\n\r\nФормат ввода\r\nНа первой строке входного файла находятся два положительных целых числа, разделенные пробелом \"— M и N ().\r\n\r\nФормат вывода\r\nВыведите в выходной файл единственное число \"— количество различных симпатичных узоров, которые можно выложить во дворе размера M × N. Узоры, получающиеся друг из друга сдвигом, поворотом или отражением считаются различными.','Найти количество способов раскрасить таблицу в два цвета, чтобы в любом квадрате 2 \\times 2 были оба цвета.','ДП по профилю или по изломанному профилю, и то и другое должно заходить','ЯК 12973 E2',''),(131,'Цены',0,'Байтазар работает экспедитором в одном из байтландских ресторанов. Каждый вечер он получает от руководства список продуктов, которые требуется закупить. Продукты должны быть куплены утром следующего дня. Байтазар должен купить ровно одну упаковку каждого из продуктов в списке. При этом суммарные затраты на закупки должны быть минимальными.\r\n\r\nВечером Байтазар узнаёт цены на все требуемые продукты в ближайших оптовых магазинах. Также Байтазару известны затраты на поездку от ресторана до каждого магазина и обратно. Байтазару требуется составить план покупок на утро.\r\n\r\nПри закупках продуктов Байтазар действует по следующей схеме: он едет от ресторана до магазина, закупает там все продукты, которые планировал, после чего отвозит продукты в ресторан. При этом, в соответствии с санитарными нормами, Байтазар во время одной поездки может покупать продукты только в одном магазине.\r\n\r\nНапишите программу, которая определяет минимальные суммарные затраты на закупки продуктов из списка.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит два целых числа n и m (1 ≤ n ≤ 100, 1 ≤ m ≤ 16) — количество оптовых магазинов и количество наименований продуктов, которые должен купить Байтазар.\r\n\r\nПоследующие n строк содержат описания цен в каждом из оптовых магазинов.\r\n\r\nПервое число в i-й из этих строк di (1 ≤ di ≤ 1 000 000) задаёт стоимость поездки от ресторана до i-го оптового магазина и обратно. Далее следуют m целых чисел ci,1, ci,2, …, ci,m (1 ≤ ci,j ≤ 1 000 000), где ci,j задаёт цену на упаковку j-го продукта в i-м магазине.\r\n\r\nФормат вывода\r\nВыведите одно целое число — минимальные суммарные затраты на закупки всех продуктов из списка.','Есть много магазинов и много продуктов, в каждом свои цены, поход в магазин не бесплатен. Найти минимальную суммарную стоимость.','Что-то с подмножествами, не помню что, потом допишу','ЯК 12973 F2','Написать более внятный разбор'),(132,'Доминошки',0,'Вам дано клетчатое поле размера n × m клеток. Некоторые клетки на этом поле отмечены как занятые. На нем необходимо разместить несколько (возможно, 0) доминошек размера 1 × 2, соблюдая следующие ограничения:\r\n\r\nкаждая клетка может быть покрыта не более чем одной доминошкой\r\nникакие две соседних по стороне клетки не могут быть заняты разными доминошками\r\nСколькими способами можно это сделать?\r\n\r\nФормат ввода\r\nВ первой строке входного файлы содержится два целых числа: n и m (1 ≤ n ≤ 6,1 ≤ m ≤ 100). В следующих n строках содержится описание поля. Символ X означает занятую клетку, символ . означает свободную клетку.\r\n\r\nФормат вывода\r\nВыведите одно целое число — количество способов разместить доминошки, взятое по модулю 109 + 7.\r\n\r\n','Сколькими способами можно разместить доминошки на поле? Никакие две доминошки не могут быть рядом','хз))','ЯК 12973 G2','Добавить разбор'),(133,'Голод',54,'И когда Он снял третью печать, я слышал третье животное, говорящее: иди и смотри.\r\nЯ взглянул, и вот, конь вороной, и на нем всадник, имеющий меру в руке своей.\r\nИ слышал я голос посреди четырех животных, говорящий: хиникс пшеницы за динарий, и три хиникса ячменя за динарий;\r\nелея же и вина не повреждай.\r\n\r\n(Откровение Иоанна Богослова)\r\n\r\nДо конца света осталось не так много дней, но Третий всадник Апокалипсиса Голод так и не смог понять, какие города стоит наказывать за прегрешения, а какие нет. Тогда он решил потренироваться на одной небольшой стране.\r\n\r\nЭта страна представляет собой клетчатый прямоугольник размера n × m, в котором каждая клетка — отдельный город. Голод может либо наслать голод на город, либо пощадить его. При этом есть города, в которых еды хватит и до следующего конца света, и Голод не в силах заставить их голодать, а есть те, в которых еды никогда и не было, и им в любом случае придется голодать.\r\n\r\nСтрашный Суд Голода должен быть еще и справедлив, а это значит, что в любом квадрате размера 2 × 2 должно быть поровну голодающих и сытых городов. Теперь Голод хочет узнать количество различных вариантов распределения городов этой страны на голодающие и сытые.\r\n\r\nФормат ввода\r\nВ первой строке входного файла задано два целых числа n и m (n ≤ 15 и m ≤ 100) — размер страны. Далее следует n строк по m символов в каждой, где символ \'+\' означает, что соответствующий город не может голодать, символ \'-\' — соответствующий город будет голодать в любом случае и символ \'.\' — Голод может решить, что ему делать с этим городом.\r\n\r\nФормат вывода\r\nВыведите количество различных вариантов наслать голод на эту страну по модулю 109 + 7','Найти количество способов покрасить таблицу в два цвета так, чтобы в каждом квадрате 2 \\times 2 было поровну цветов','ДП по изломанному профилю','ЯК 12973 H2',''),(134,'Великая сеча',24,'Алеша Попович и Добрыня Никитич сражаются со стаей двух- и трехголовых драконов. Они по очереди взмахивают мечами, и одним махом могут отрубить любое (по своему желанию) число голов, но только у одного дракона. Отрубивший последнюю голову у последнего дракона получает в жены прекрасную принцессу.\r\n\r\nКто из богатырей (начинающий или второй) может получить в жены принцессу независимо от действий другого?\r\n\r\nФормат ввода\r\nВо входном файле записано два числа N и M — количество двух- и трехголовых драконов соответственно (оба числа целые из диапазона от 0 до 100).\r\n\r\nФормат вывода\r\nВ выходной файл выведите сначала число 1 или 2, определяющее, кто из богатырей имеет все шансы получить в жены принцессу (1 — тот, кто начинает, 2 — второй). В случае 1 выведите также все варианты его первого хода, которые к этому приводят: сначала выведите количество различных выигрышных ходов (при этом отрубание одинакового количества голов у разных двухголовых драконов считается одним и тем же ходом, так же и для трехголовых), а затем сами ходы. Каждый ход задается парой чисел: первое число определяет у сколькиголового дракона нужно отрубать головы, а второе — сколько голов нужно отрубать. Ходы выводить в порядке возрастания количества голов у дракона, а при равенстве — в порядке возрастания количества отрубаемых голов.','Ним с кучками из 2 и 3 камней','Ним. Поскольку кучки маленького размера, можно сделать что-то равносильное, не произнося явно слово \"Ним\".','ЯК 12973 A3',''),(135,'Шоколадка - революция',37,'Петя получил золотую медаль на IOI, за что от правительства ему положена благодарность в виде шоколадки. На данный момент имеется N видов шоколадок, которые производит государственная шоколадная фабрика. У каждой шоколадки есть стоимость. Кроме того, у каждого вида, кроме шоколадки «Юлька», есть вид-прародитель. Известно, что прародителем может быть только шоколадка, которая была выпушена хронологически раньше. Исторически самый первый вид — «Юлька». Чиновник и Петя выбирают шоколадку ему в подарок. При этом цель первого — сэкономить, второго —- получить настолько дорогую шоколадку, насколько это возможно.\r\n\r\nНачинается выбор с «Юльки». Петя за ход либо берет текущую шоколадку, либо меняет свой выбор на шоколадку-потомка (если это возможно). Чиновнику же кажется, что позже выпущенные виды хуже и дешевле, поэтому он меняет выбор на шоколадку-потомка (если это возможно), либо покупает Пете шоколадку (если потомков нет). Они ходят по очереди, Петя — первый. Определите, на шоколадку какой стоимости может претендовать Петя.\r\n\r\nФормат ввода\r\nСначала вводится число 0 < N ≤ 2 ⋅ 105 — количество видов. «Юлька» имеет номер 1. Далее идут N строк с парами чисел 0 ≤ Pi ≤ N — номер сорта-предка (для шоколадки «Юлька» указан 0, у остальных Pi > 0) и 0 < Ci ≤ 109 — стоимость i-го сорта.\r\n\r\nФормат вывода\r\nВыведите стоимость шоколадки, которую Петя может себе гарантировать при правильных действиях.','Два игрока спускаются по дереву, один может в любой момент остановиться. Один максимизирует, другой минимизирует, найти что получится.','Ретроанализ в спуске по дереву','ЯК 12973 B3',''),(136,'Ретроанализ для маленьких',0,'Дан ориентированный весёлый граф из \r\nn\r\n вершин и \r\nm\r\n ребер. Оля и Коля в игру. Изначально фишка стоит в вершине \r\ni\r\n. За ход можно передвинуть фишку по любому из исходящих ребер. Тот, кто не может сделать ход, проигрывает. Ваша задача — для каждой вершины \r\ni\r\nопределить, кто выиграет при оптимальной игре обоих.\r\nФормат ввода\r\nВходные данные состоят из одного или нескольких тестов. Каждый тест содержит описание весёлого ориентированного графа. Граф описывается так: на первой строке два целых числа \r\nn\r\n (\r\n1\r\n≤\r\nn\r\n≤\r\n3\r\n0\r\n0\r\n0\r\n0\r\n0\r\n) и \r\nm\r\n (\r\n1\r\n≤\r\nm\r\n≤\r\n3\r\n0\r\n0\r\n0\r\n0\r\n0\r\n). Следующие \r\nm\r\n строк содержат ребра графа, каждое описывается парой целых чисел от \r\n1\r\n до \r\nn\r\n. Пара \r\na\r\nb\r\n обозначает, что ребро ведет из вершины \r\na\r\n в вершину \r\nb\r\n. В графе могут быть петли, могут быть кратные ребра. Сумма \r\nn\r\n по всем тестам не превосходит \r\n3\r\n0\r\n0\r\n0\r\n0\r\n0\r\n, сумма \r\nm\r\n по всем тестам также не превосходит \r\n3\r\n0\r\n0\r\n0\r\n0\r\n0\r\n.\r\nФормат вывода\r\nДля каждого теста выведите для каждой вершины FIRST, SECOND или DRAW в зависимости от того, кто выиграет при оптимальной игре из этой вершины. Ответы к тестам разделяйте пустой строкой.\r\n','Можно ходить по ориентированному графу. Проиграет тот, кто не может пойти.','Пока непонятно','ЯК 12973 C3','Добавить разбор'),(137,'Терминатор',31,'Два игрока играют в настольную игру. Игровое поле представляет собой квадратный лабиринт, 8× 8 клеток. В некоторых клетках располагаются стенки. Один игрок управляет фишкой-терминатором, а второй — фишкой-беглецом. Игроки ходят по очереди, ходы пропускать нельзя (гарантируется, что ход всегда возможен). За один ход игрок может переместить свою фишку в любую из свободных клеток, расположенных рядом с исходной по горизонтали, вертикали или по диагонали (то есть ходом короля). Терминатор, кроме того, может стрелять в беглеца ракетами. Выстрел идет по прямой в любом направлении по горизонтали, вертикали или диагонали. Если беглец оказывается на линии выстрела терминатора и не прикрыт стенками, то терминатор незамедлительно делает выстрел (вне зависимости от того, чей ход), и беглец проигрывает. Начальное положение фишек задано. Первый ход делает беглец. Он выигрывает, если сделает ход с восьмой строки за пределы игрового поля, так как остальные границы поля окружены стенками.\r\n\r\nВопрос задачи: может ли беглец выиграть при оптимальной игре обеих сторон?\r\n\r\nФормат ввода\r\nВо входном файле задано игровое поле. Свободная клетка обозначена цифрой 0, а клетка со стенкой — цифрой 1. Клетка, в которой находится беглец, обозначена цифрой 2, а клетка с терминатором — цифрой 3.\r\n\r\nФормат вывода\r\nВ выходной файл выведите число 1, если беглец выигрывает, и -1 — в противном случае.\r\n\r\n','Терминатор и беглец бегают по полю. Терминатор может стрелять, беглецу нельзя попадать на линию выстрела. Ходят по очереди, кто выиграет?','Есть 64 игровые позиции, на них построим ретроанализ','ЯК 12973 D3',''),(138,'Шоколадка',41,'Двое играют в такую игру: перед ними лежит шоколадка размера N × M. За ход можно разломить имеющийся кусок шоколадки вдоль одной из сторон на 2 «непустых».\r\n\r\nОднако, нельзя разламывать куски размером не больше, чем 1 × k (куски можно поворачивать; мы считаем, что один кусок «не больше» другого, если он равен ему или его части). Таким образом, нельзя разламывать куски размером 1 × 1, 1 × 2, …, 1 … k, а остальные куски разламывать можно.\r\n\r\nПроигрывает тот, кто не может сделать ход. Определите, кто же станет победителем в игре, если известны начальные размеры шоколадки.\r\n\r\nФормат ввода\r\nВводятся целые числа 0 < N, M, K ≤ 100.\r\n\r\nФормат вывода\r\nВывести 1 или 2 — номер игрока, который выиграет при правильной игре.','Разламываем шоколадку вдоль ложбинок. Нельзя разламывать шоколадки меньше чем 1 \\times k.','Ретроанализ + ним','ЯК 12973 E3',''),(139,'Малыш и Карлсон',60,'На свой День рождения Малыш позвал своего лучшего друга Карлсона. Мама испекла его любимый пирог прямоугольной формы a × b × c сантиметров. Карлсон знает, что у Малыша еще есть килограмм колбасы. Чтобы заполучить ее, он предложил поиграть следующим образом: они по очереди разрезают пирог на две ненулевые по объему прямоугольные части с целыми измерениями и съедают меньшую часть (в случае, когда части равные, можно съесть любую). Проигрывает тот, кто не может сделать хода (то есть когда размеры будут 1 × 1 × 1). Естественно, победителю достается колбаса.\r\n\r\nМалыш настаивает на том, чтобы он ходил вторым.\r\n\r\nПомогите Карлсону выяснить, сможет ли он выиграть, и если сможет — какой должен быть его первый ход для этого.\r\n\r\nСчитается, что Малыш всегда ходит оптимально.\r\n\r\nФормат ввода\r\nВо входном файле содержится 3 целых числа a, b, c (1 ≤ a, b, c ≤ 5 000) —размеры пирога.\r\n\r\nФормат вывода\r\nВ случае, если Карлсон не сможет выиграть в Малыша, выведите NO. В противном случае в первой строке выведите YES, во второй — размеры пирога после первого хода Карлсона в том же порядке, что и во входном файле.','Есть три кучи, из каждой можно забирать не больше половины. ','Над каждой кучкой в отдельности проведем ретроанализ, результат сложим при помощи Ним.','ЯК 12973 F3',''),(140,'Произведение графов',54,'Пусть дан ориентированный ациклический граф. Стандартная игра на графе заключается в следующем: изначально на одной из вершин графа (называемой начальной позицией) стоит фишка. Двое игроков по очереди двигают её по рёбрам. Проигрывает тот, кто не может сделать ход.\r\n\r\n\r\nВ теории игр часто рассматриваются более сложные игры. Например, прямое произведение двух игр на графах. Прямое произведение игр — это следующая игра: изначально на каждом графе в начальной позиции стоит по фишке. За ход игрок двигает обе фишки по рёбрам (каждую фишку двигает в собственном графе). Проигрывает тот, кто не может сделать ход. То есть тот, кто не может сделать ход хотя бы в одной игре.\r\n\r\n\r\nВаша задача — опеределить, кто выиграет при правильной игре.\r\n\r\n\r\nФормат ввода\r\nНа первой строке будут даны числа N1 и M1 — количество вершин и рёбер в первом графе (1 ≤ N1,  M1 ≤ 100 000). На следующих M1 строках содержится по два числа x и y (1 ≤ x,   y ≤ N1).\r\n\r\n\r\nВ следующих M2 + 1 строках задан второй граф в том же формате.\r\n\r\n\r\nЗаканчивается входной файл списком пар начальных вершин, для которых нужно решить задачу. На первой строке задано число T (1≤ T≤ 100 000) — количество пар начальных вершин. В следующих T строках указаны пары вершин v1 и v2 (1 ≤ v1 ≤ N1, 1 ≤ v2 ≤ N2).\r\n\r\n\r\nУчтите, что в графах могут быть кратные рёбра.\r\n\r\n\r\nФормат вывода\r\nНа каждую из T пар начальных вершин выведите строку “first”, если при правильной игре выиграет первый, и “second”, если второй.','На двух графах каждый ход двигают обе фишки. Проиграет тот, кто не сможет походить хотя бы в одном графе.','Скорее всего, какой-то ретроанализ, надо потом посмотреть внимательнее','ЯК 12973 G3','Додумать разбор'),(141,'Корневой ним',44,'Для игры в корневой ним используются следующие правила. Перед двумя игроками лежит кучка из n камней. Они по очереди забирают оттуда камни. Если в кучке сейчас лежат k камней, то игрок может взять из неё от 1 до  камней, включительно. Напрмер, из кучки из 10 камней можно брать 1, 2 или 3 камня. Проигрывает игрок, который не может сделать ход.\r\n\r\n\r\nПо заданному n определите, победит ли первый игрок при правильной игре обоих игроков.\r\n\r\n\r\nФормат ввода\r\nВходной файл содержит единственное число n (1 ≤ n ≤ 1012) — количество камней в кучке.\r\n\r\n\r\nФормат вывода\r\nВыведите WIN в случае победы первого игрока, и LOSE, если ему победить не удастся.','Из кучки можно брать не более sqrt(размер кучи) камней, сказать, кто выиграет.','Между очередными двумя квадратами можно за O(1) сделать простой ретроанализ --- достаточно знать лишь номер последней проигрышной позиции.','ЯК 12973 H3',''),(142,'Вариация Нима',49,'На столе лежат n кучек камней: a1 камней в первой кучке, a2 камней во второй, …, an в n-ой. Двое играют в игру, делая ходы по очереди. За один ход игрок может либо взять произвольное ненулевое количество камней (возможно, все) из одной любой кучки, либо произвольным образом разделить любую существующую кучку, в которой не меньше двух камней, на две непустые кучки. Проигрывает тот, кто не может сделать ход. Кто выигрывает при правильной игре?\r\n\r\n\r\nФормат ввода\r\nВ первой строке задано целое число t — количество тестов (1 ≤ t ≤ 100). Следующие t строк содержат сами тесты. Каждая из них начинается с целого числа n — количества кучек (1 ≤ n ≤ 100). Далее следует n целых чисел a1, a2, …, an через пробел — количество камней в кучках (1 ≤ ai ≤ 109).\r\n\r\n\r\nФормат вывода\r\nВыведите t строк; в i-ой строке выведите “FIRST”, если в i-ом тесте при правильной игре выигрывает первый игрок, и “SECOND”, если второй.','Ним, но дополнительно каждую кучку можно разбивать на две непустые.','Видимо, в этой задаче функция Шпрага-Гранди тривиально зависит от остатка при делении на 4 размера кучки.','ЯК 12973 I3',''),(143,'Египетские дни рождения',20,'В недавней археологической экспедиции в Египте Василий Ильич и его коллеги нашли каменную плиту, на которой было много похожих записей. По ряду причин археологи решили, что это — списки рабов, задействованных на строительстве пирамид: их имена, дни рождения, родные города. Василий Ильич очень интересуется, как же надсмотрщики различали рабов, если у них совпадали все эти параметры. Для начала он хочет определить, сколько среди записей на плите различны. Помогите ему.\r\n\r\n\r\nФормат ввода\r\nПервая строка содержит число n () - количество записей на плите. Далее n строк, содержащих записи. Каждая строка состоит из маленьких латинских букв, не превосходит по длине 100 символов и не является пустой. Гарантируется, что размер входного файла не превосходит 1 Мб.\r\n\r\n\r\nФормат вывода\r\nВыведите количество различных записей.\r\n\r\n','Сколько из данных строк различны?','Заведем сет и в него всё покидаем.\r\n\r\nПостроим бор и выведем количество терминальных вершин.','ЯК 12973 A4','Задача выглядит как задача на бор, но в ней заходит решение с сетом. Возможно, стоит повысить ограничения'),(144,'Словарь',27,'Дан набор слов и текст, требуется определить для каждого слова, присутствует ли оно в тексте как подстрока.\r\n\r\n\r\nФормат ввода\r\nВ первой строке дан текст (не более 106 строчных латинских букв). Далее дано число M — количество слов в словаре.\r\n\r\n\r\nВ следующих M строках записаны слова (не более 30 строчных латинских букв). Слова различны и отсортированы в лексикографическом порядке.\r\n\r\n\r\nСуммарная длина слов в словаре не более 105.\r\n\r\n\r\nФормат вывода\r\nM строк вида Yes, если слово присутствует, и No иначе.','Для данного набора слов найти все его вхождения в текст.','Алгоритм Ахо-Корасик решает задачу.','ЯК 12973 B4',''),(145,'K-я строка',24,'Реализуйте структуру данных, которая поддерживает следующие операции:\r\n\r\n\r\nдобавить в словарь строку S;\r\n\r\n\r\nнайти в словаре k-ю строку в лексикографическом порядке.\r\nИзвестно, что изначально словарь пуст.\r\n\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит натуральное число N — количество команд (). Последующие N строк содержат по одной команде каждая.\r\n\r\n\r\nКоманда записывается либо в виде числа k, либо в виде строки S, которая может состоять только из строчных латинских букв. Гарантируется, что при запросе k-й строки она существует. Также гарантируется, что сумма длин всех добавляемых строк не превышает 105.\r\n\r\n\r\nФормат вывода\r\nДля каждого числового запроса k выходной файл должен содержать k-ю в лексикографическом порядке строчку из словаря на момент запроса. Гарантируется, что суммарная длина строк в выходном файле не превышает 105.','Два запроса --- добавить строку и найти k-ю в лексикографическом порядке.','Построим сжатый бор и будем делать спуск по бору','ЯК 12973 C4',''),(146,'Шифр Бэкона',32,'Программисту Васе не повезло — вместо отпуска его послали в командировку на научную конференцию. «Надо повышать уровень знаний», — сказал начальник, «Важная конференция по криптографии, проводится во Франции —а там шифровали еще во времена Ришелье и взламывали чужие шифры еще во времена Виета.»\r\n\r\n\r\nВася быстро выяснил, что все луврские картины он уже где-то видел, вид Эйфелевой башни приелся ему еще раньше, чем мышка стерла его с коврика, а такие стеклянные пирамиды у нас делают надо всякими киосками и сомнительными забегаловками. Одним словом, смотреть в Париже оказалось просто не на что, рыбу половить негде, поэтому Васе пришлось посещать доклады на конференции.\r\n\r\n\r\nОдин из докладчиков, в очередной раз пытаясь разгадать шифры Бэкона, выдвинул гипотезу, что ключ к тайнам Бэкона можно подобрать, проанализировав все возможные подстроки произведений Бэкона. «Но их же слишком много!» —вслух удивился Вася. «Нет, не так уж и много!» — закричал докладчик, — «Подсчитайте, и вы сами убедитесь!»\r\n\r\n\r\nТем же вечером Вася нашел в интернете полное собрание сочинений Бэкона. Он написал программу, которая переработала тексты в одну длинную строку, выкинув из текстов все пробелы и знаки препинания. И вот теперь Вася весьма озадачен — а как же подсчитать количество различных подстрок этой строки?\r\n\r\n\r\nФормат ввода\r\nНа входе дана непустая строка, полученная Васей. Строка состоит только из строчных латинских символов. Ее длина не превосходит 2 000 символов.\r\n\r\n\r\nФормат вывода\r\nВыведите количество различных подстрок этой строки.','Посчитать количество различных подстрок в строке','Можно всё захешировать и при помощи сета за $O(n^2logn)$ посчитать ответ.\r\n\r\n\r\nДля каждой позиции будем считать количество уникальных строк, которые в ней начинаются. Заметим, что если мы посчитаем z-функцию для соответствующего суффикса, то наибольшее ее значение - количество не уникальных строк, которые начинаются в нашей позиции, а значит все остальные - уникальные.','ЯК 12973 D4',''),(147,'Витя и странный урок',30,'Сегодня на уроке Витя изучал очень интересную функцию — mex. Mex набора чисел — минимальное неотрицательное число, не присутствующее в наборе чисел. Например, \r\nm\r\ne\r\nx\r\n(\r\n[\r\n4\r\n,\r\n3\r\n3\r\n,\r\n0\r\n,\r\n1\r\n,\r\n1\r\n,\r\n5\r\n]\r\n)\r\n=\r\n2\r\n, а \r\nm\r\ne\r\nx\r\n(\r\n[\r\n1\r\n,\r\n2\r\n,\r\n3\r\n]\r\n)\r\n=\r\n0\r\n.\r\nВитя очень быстро разобрался со всеми задачами учителя, а сможете ли вы?\r\nДаны массив, состоящий из \r\nn\r\n неотрицательных целых чисел, и \r\nm\r\n запросов. Каждый запрос характеризуется одним числом \r\nx\r\n и заключается в следующих последовательных шагах:\r\n\r\nВыполнить операцию побитового сложения по модулю \r\n2\r\n (xor) каждого элемента массива с числом \r\nx\r\n.\r\nНайти mex полученного массива.\r\nУчтите, что после каждого запроса массив изменяется.\r\n\r\nФормат ввода\r\nПервая строка содержит два целых положительных числа \r\nn\r\n и \r\nm\r\n (\r\n1\r\n≤\r\nn\r\n,\r\nm\r\n≤\r\n3\r\n⋅\r\n1\r\n0\r\n5\r\n), обозначающие количество элементов в массиве и количество запросов соответственно.\r\nСледующая строка содержит \r\nn\r\n неотрицательных целых чисел \r\na\r\ni\r\n (\r\n0\r\n≤\r\na\r\ni\r\n≤\r\n3\r\n⋅\r\n1\r\n0\r\n5\r\n), представляющих элементы исходного массива.\r\nКаждая из следующих \r\nm\r\n строк содержит запрос — одно неотрицательное целое число \r\nx\r\n (\r\n0\r\n≤\r\nx\r\n≤\r\n3\r\n⋅\r\n1\r\n0\r\n5\r\n).\r\n\r\nФормат вывода\r\nДля каждого запроса выведите ответ на него в отдельной строке.\r\n','Нужно много раз делать ^= x всем элементам массива и находить его Mex.','Заметим, что нам не нужно каждый раз обновлять весь массив --- достаточно знать число, которое ксорится с массивом.\r\n\r\nПостроим битовый бор на наших числах. В каждой вершине будем хранить размер его поддерева. Теперь легко найти Mex --- достаточно идти в $0$ каждый раз, когда он не полон. Теперь если нужно все числа проксорить с $x$, то мы меняем $0$ на $1$ и наоборот каждый раз, когда в числе $x$ на очередном месте встретилась $1$.','ЯК 12973 E4',''),(148,'Вирусы',61,'Комитет По Исследованию Бинарных Вирусов обнаружил, что некоторые последовательности единиц и нулей являются кодами вирусов. Комитет изолировал набор кодов вирусов. Последовательность из единиц и нулей называется безопасной, если никакой ее сегмент (т.е. последовательность из соседних элементов) не является кодом вируса. Сейчас цель комитета состоит в том, чтобы установить, существует ли бесконечная безопасная последовательность из единиц и нулей.\r\nФормат ввода\r\nПервая строка входного файла virus.in содержит одно целое число \r\nN\r\n, равное количеству всех вирусных кодов. Каждая из следующих n строк содержит непустое слово, составленное из символов 0 и 1 — код вируса. Суммарная длина всех слов не превосходит \r\n3\r\n0\r\n0\r\n0\r\n0\r\n.\r\nФормат вывода\r\nПервая и единственная строка выходного файла должна содержать слово:\r\nTAK — если бесконечная, безопасная последовательность из нулей и единиц сушествует;\r\nNIE — в противном случае.','Есть бесконечная строка, не содержащая как подстроку ни одну из запрещённых?','Построим Ахо-Корасик. Если мы будем ему скармливать нашу бесконечную строку, то будем бесконечно ходить по автомату, не заходя в терминальные вершины. Поскольку число вершин конечно, то когда-нибудь мы окажемся в вершине, в которой уже были, а значит зациклились. Получается, что такая строка существует, если есть цикл в Ахо-Корасике, который ни разу не проходит по терминальным вершинам.','ЯК 12973 F4','Непонятно, мб надо в теги bfs добавить. В условии написано что-то про virus.in, это не соответствует реальности, надо убрать.'),(149,'Под-бор',0,'Бором называется подвешенное дерево, на каждом из рёбер которого написано по символу, причём символы, написанные на рёбрах, выходящих из общей вершины-родителя, различны. Будем называть направление от родителя к детям “вниз”. Назовем вхождением строки\r\ns\r\n в бор такую вершину бора, от которой можно пройти несколько шагов вниз таким образом, что встретившиеся символы образуют строку \r\ns\r\n.\r\nДаны бор и несколько строк, найдите сумму количеств вхождений этих строк в этот бор.\r\n\r\nФормат ввода\r\nВ первой строке входного файла записано единственное число \r\nn\r\n, \r\n1\r\n≤\r\nn\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\n — количество вершин бора. В следующих \r\nn\r\n строках описаны вершины бора. В (\r\ni\r\n+\r\n1\r\n)-й строке описаны дети \r\ni\r\n-й вершины: число \r\nk\r\ni\r\n ее детей, затем \r\nk\r\ni\r\n пар из номера вершины-ребёнка и символа, написанного на соответствующем ребре. Номер родителя всегда меньше номера ребёнка; корнем бора является вершина номер 1.\r\nВ (\r\nn\r\n+\r\n2\r\n)-й строке записано количество \r\nm\r\n (\r\n1\r\n≤\r\nm\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\n) строк для поиска. В следующих \r\nm\r\n строках перечислены сами строки. Входные строки непусты, а их суммарная длина не превышает \r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\n символов.\r\nВсе символы, написанные на рёбрах, а также все символы, составляющие строки — маленькие латинские буквы.\r\n\r\nФормат вывода\r\nВыведите одно число — сумму количеств вхождений.','Дан бор и множество строк. Требуется найти сумму по всем строкам количество их вхождений в бор.','','ЯК 12973 G4','Написать разбор'),(150,'Наименьшее общее кратное',8,'Заданы два целых положительных числа a и b. Найти их наименьшее общее кратное\r\n\r\nФормат ввода\r\nВ первой строке входа заданы два целых числа a и b (1 ≤ a,b ≤ 109).\r\n\r\nФормат вывода\r\nОдно число — наименьшее целое положительное число, которое делится на оба введённых числа.','Найти НОК','$\\frac{a \\cdot b}{gcd(a, b)}$','ЯК 12972 A8',''),(151,'Сильно составные числа',12,'Выведите все числа в диапазоне от 2 до N, у которых есть хотя бы три различных простых делителя.\r\n\r\nФормат ввода\r\nВводится одно натуральное число N ().\r\n\r\nФормат вывода\r\nВыведите через пробел в возрастающем порядке все искомые числа.','Найти все числа, у которых хотя бы 3 простых делителя','Пробегаемся решетом и для каждого числа считаем количество его простых делителей.','ЯК 12972 B8',''),(152,'Обратное по простому модулю',20,'В данной задаче Вам необходимо найти для натурального числа a такое натуральное число x, не большее 109+9, что a*x - 1 делится на 109 + 9.\r\n\r\nФормат ввода\r\nВ первой строке записано число T, 1 ≤ T ≤ 105 - количество тестовых примеров. В каждой из следующих T строк записано натуральное число a, 1 ≤ a < 109 + 9.\r\n\r\nФормат вывода\r\nДля каждого числа a выведите в отдельной строке одно число - ответ на задачу. Ответ не должен превышать 109+9.','Найти обратный элемент по простому модулю','Бинарное возведение в степень + малая теорема Ферма','ЯК 12972 C8',''),(153,'C_n_k',16,'В этой задаче вам нужно посчитать следующую сумму:  mod P, где P = 109 + 7. В случае n < mk следует считать, что Cnmk = 0.\r\n\r\nФормат ввода\r\nЕдинственная строка входного файла содержит положительные целые числа n, m и l ().\r\n\r\nФормат вывода\r\nВыведите одно целое число - требуемую сумму.','Найти сумму нескольких биномиальных коэффициентов по модулю','Предподсчитаем все факториалы и обратные к ним, тогда каждую цешку можно считать за O(1)','ЯК 12972 D8',''),(154,'Диофантово уравнение',20,'В данной задаче Вам всего лишь необходимо найти решение диофантова уравнения.\r\n\r\nФормат ввода\r\nВ первой строке записано число T - количество тестовых примеров, T ≤ 105. В каждой из следующих T строк записаны целые числа a, b, c, 1 ≤ a, b, c ≤ 109.\r\n\r\nФормат вывода\r\nДля каждой тройки чисел a, b, c в отдельной строке выведите два целых числа x, y, -109 ≤ x, y ≤ 109, т.ч. a*x + b*y = c. Если таких решений несколько, выведите решение с минимально возможным неотрицательным целым x. Если же решения не существует, выведите в соответствующую строку два нуля.','Решить диофантово уравнение','http://e-maxx.ru/algo/diofant_2_equation','ЯК 12972 E8',''),(155,'Китайская теорема',17,'Решите в целых числах систему уравнений\r\n\r\nx = a(mod n)\r\ny = b(mod m)\r\n\r\n,\r\n\r\nгде n и m взаимно просты. Среди решений следует выбрать наименьшее неотрицательное число.\r\n\r\nФормат ввода\r\nВходной файл содержит четыре целых числа a, b, n и m (1 \r\n n, m \r\n 106, 0 \r\n a < n, 0 \r\n b < m).\r\n\r\nФормат вывода\r\nВ выходной файл выведите искомое наименьшее неотрицательное число x.','Найти пример из китайской теоремы об остатках','Надо воспользоваться конструктивным доказательством из китайской теоремы об остатках','ЯК 12972 F8',''),(156,'Большие простые числа',16,'Найдите все простые в диапазоне \r\n[\r\nA\r\n.\r\n.\r\nB\r\n]\r\n.\r\nФормат ввода\r\nДаны \r\n1\r\n≤\r\nA\r\n≤\r\nB\r\n≤\r\n1\r\n0\r\n1\r\n2\r\n. Дополнительно известно \r\n∣\r\n∣\r\nB\r\n−\r\nA\r\n∣\r\n∣\r\n≤\r\n1\r\n0\r\n6\r\n.\r\nФормат вывода\r\nВ строку все простые числа из диапазона в порядке возрастания.\r\n','Найти все простые числа в маленьком диапазоне больших чисел','Надо аккуратно \"прорешетить\" этот диапазон','ЯК 12972 G8',''),(157,'Четвёртый этаж',40,'Знаете ли вы, почему четвертый этаж заперт и там не останавливается лифт? Потому что на самом деле четвертый, запертый, этаж, где не останавливается лифт, содержит бесконечное количество комнат, пронумерованных натуральными числами. На этот этаж регулярно приезжают дети, каждый из которых заранее выбрал, в какую комнату он хочет заселиться. Если выбранная комната оказывается свободна, то ребенок занимает ее, в противном случае он занимает первую свободную комнату с бoльшим номером.\r\n\r\nКроме того, некоторые дети уезжают в середине смены. Сразу после отъезда ребенка его комната становится доступна для заселения следующего.\r\n\r\nПромоделируйте работу преподавателей, ответственных за четвертый этаж и научитесь быстро сообщать приезжающим детям, какую комнату им следует занимать.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит натуральное число n — количество прибытий и отъездов, происходящих в течение смены ().\r\n\r\nСледующие n строк содержат информацию об ЛКШатах. Число a > 0 обозначает, что приехал школьник, желающий занять комнату номер a (). Число a < 0 обозначает, что из комнаты номер |a| уехал школьник. (Гарантируется, что эта комната не была пуста).\r\n\r\nФормат вывода\r\nДля каждого приезжающего школьника выведите одно натуральное число —номер комнаты, в которую он поселится.','Бесконечный ряд комнат, надо уметь их освобождать и находить ближайшую свободную к данной','Можно с помощью сета или дерева отрезков моделировать процесс','ЯК 12973 A5',''),(158,'Менеджер памяти',40,'Пете поручили написать менеджер памяти для новой стандартной библиотеки языка H++. В распоряжении у менеджера находится массив из N последовательных ячеек памяти, пронумерованных от 1 до N. Задача менеджера — обрабатывать запросы приложений на выделение и освобождение памяти. Запрос на выделение памяти имеет один параметр K. Такой запрос означает, что приложение просит выделить ему K последовательных ячеек памяти. Если в распоряжении менеджера есть хотя бы один свободный блок из K последовательных ячеек, то он обязан в ответ на запрос выделить такой блок. При этом наш менеджер выделяет память из самого длинного свободного блока, а если таких несколько, то из них он выбирает тот, у которого номер первой ячейки — наименьший. После этого выделенные ячейки становятся занятыми и не могут быть использованы для выделения памяти, пока не будут освобождены. Если блока из K последовательных свободных ячеек нет, то запрос отклоняется. Запрос на освобождение памяти имеет один параметр T. Такой запрос означает, что менеджер должен освободить память, выделенную ранее при обработке запроса с порядковым номером T. Запросы нумеруются, начиная с единицы. Гарантируется, что запрос с номером T — запрос на выделение, причем к нему еще не применялось освобождение памяти. Освобожденные ячейки могут снова быть использованы для выделения памяти. Если запрос с номером T был отклонен, то текущий запрос на освобождение памяти игнорируется. Требуется написать симуляцию менеджера памяти, удовлетворяющую приведенным критериям.\r\n\r\nФормат ввода\r\nВ первой строке входа два числа N и M — количество ячеек памяти и запросов соответственно (1 ≤ N ≤ 231 - 1, 1 ≤ M ≤ 105). Каждая из следующих M строк содержит по одному числу. (i + 1)-я строка содержит положительное число K, если i-й запрос — запрос на выделение K ячеек памяти (1 ≤ K ≤ N), и отрицательное число -T, если i-й запрос — запрос на освобождение памяти, выделенной по запросу номер T (1 ≤ T < i).\r\n\r\nФормат вывода\r\nДля каждого запроса на выделение памяти выведите в выход одно число на отдельной строке с результатом выполнения этого запроса. Если память была выделена, выведите номер первой ячейки памяти в выделенном блоке, иначе выведите число -1.\r\n\r\n','Нужно уметь быстро занимать, освобождать сегмент и находить самый большой свободный сегмент.','Можно моделировать процесс при помощи set, либо динамическим деревом отрезков','ЯК 12973 B5',''),(159,'Миллиардеры',20,'Возможно, вы знаете, что из всех городов мира больше всего миллиардеров живёт в Москве. Но, поскольку работа миллиардера подразумевает частые перемещения по всему свету, в определённые дни какой-то другой город может занимать первую строчку в таком рейтинге. Ваши приятели из ФСБ, ФБР, MI5 и Шин Бет скинули вам списки перемещений всех миллиардеров за последнее время. Ваш работодатель просит посчитать, сколько дней в течение этого периода каждый из городов мира был первым по общей сумме денег миллиардеров, находящихся в нём.\r\nФормат ввода\r\nВ первой строке записано число \r\nn\r\n — количество миллиардеров (\r\n1\r\n≤\r\nn\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n). Каждая из следующих \r\nn\r\n строк содержит данные на определённого человека: его имя, название города, где он находился в первый день данного периода, и размер состояния. В следующей строке записаны два числа: \r\nm\r\n — количество дней, о которых есть данные (\r\n1\r\n≤\r\nm\r\n≤\r\n5\r\n0\r\n0\r\n0\r\n0\r\n), \r\nk\r\n — количество зарегистрированных перемещений миллиардеров (\r\n0\r\n≤\r\nk\r\n≤\r\n5\r\n0\r\n0\r\n0\r\n0\r\n). Следующие \r\nk\r\n строк содержат список перемещений в формате: номер дня (от \r\n1\r\n до \r\nm\r\n−\r\n1\r\n), имя человека, название города назначения. Вы можете считать, что миллиардеры путешествуют не чаще одного раза в день, и что они отбывают поздно вечером и прибывают в город назначения рано утром следующего дня. Список упорядочен по возрастанию номера дня. Все имена и названия городов состоят не более чем из \r\n2\r\n0\r\n латинских букв, регистр букв имеет значение. Состояния миллиардеров лежат в пределах от \r\n1\r\n до \r\n1\r\n0\r\n0\r\n миллиардов.\r\nФормат вывода\r\nВ каждой строке должно содержаться название города и, через пробел, количество дней, в течение которых этот город лидировал по общему состоянию миллиардеров, находящихся в нём. Если таких дней не было, пропустите этот город. Города должны быть отсортированы по алфавиту (используйте обычный порядок символов: ABC...Zabc...z).','Дан граф и перемещения людей по нему. Нужно для каждого города определить, сколько дней он был самым большим по содержимому денег.','Задача на то, чтобы несколькими ассоциативными массивами аккуратно промоделировать процесс.','ЯК 12973 C5',''),(160,'Окно',15,'Рассмотрим последовательность целых чисел длины \r\nN\r\n. По ней с шагом 1 двигается “окно” длины \r\nK\r\n, то есть сначала в “окне” видно первые \r\nK\r\n чисел, на следующем шаге в “окне” уже будут находиться \r\nK\r\n чисел, начиная со второго, и так далее до конца последовательности.\r\nТребуется для каждого положения “окна” определить минимум в нём.\r\n\r\nФормат ввода\r\nВ первой строке входных данных содержатся два числа \r\nN\r\n и \r\nK\r\n ( \r\n1\r\n≤\r\nN\r\n≤\r\n1\r\n5\r\n0\r\n0\r\n0\r\n0\r\n,\r\n1\r\n≤\r\nK\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n, \r\nK\r\n≤\r\nN\r\n) — длины последовательности и “окна”, соответственно. На следующей строке находятся \r\nN\r\n чисел — сама последовательность.\r\nФормат вывода\r\nВыходые данные должны содержать \r\nN\r\n−\r\nK\r\n+\r\n1\r\n строк — минимумы для каждого положения “окна”.','Для движущегося по массиву окна требуется определять минимум в нём.','Мультисетом поддерживаем множество чисел в окне','ЯК 12973 D5',''),(161,'Сумма на отрезке',30,'Дан массив из \r\nN\r\n элементов, нужно научиться находить сумму чисел на отрезке.\r\nФормат ввода\r\nПервая строка содержит два целых числа \r\nN\r\n и \r\nK\r\n — число чисел в массиве и количество запросов. \r\n(\r\n1\r\n≤\r\nN\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\n)\r\n, \r\n(\r\n0\r\n≤\r\nK\r\n≤\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\n)\r\n. Следующие \r\nK\r\n строк содержат запросы\r\n“A i x” — присвоить \r\ni\r\n-му элементу массива значение \r\nx\r\n (\r\n1\r\n≤\r\ni\r\n≤\r\nn\r\n, \r\n0\r\n≤\r\nx\r\n≤\r\n1\r\n0\r\n9\r\n)\r\n“Q l r” — найти сумму чисел в массиве на позициях от \r\nl\r\n до \r\nr\r\n. (\r\n1\r\n≤\r\nl\r\n≤\r\nr\r\n≤\r\nn\r\n)\r\nИзначально в массиве живут нули.\r\n\r\nФормат вывода\r\nНа каждый запрос вида Q l r нужно вывести единственное число — сумму на отрезке.','Требуется присваивать в точке и находить сумму на отрезке','Простое дерево отрезков это сделает','ЯК 12973 E5',''),(162,'Опять k-я статистика',30,'Изначально вам дан массив целых чисел.\r\n\r\nНужно уметь отвечать на три запроса:\r\n\r\n+ i x — Вставить на i-ю позицию число x (размер массива увеличивается на 1)\r\n- i — Удалить число на i-й позиции (размер массива уменьшается на 1)\r\n? L R x — Сказать, сколько чисел y на позициях L \r\n i \r\n R таких, что y \r\n x (|x| \r\n 109)\r\nФормат ввода\r\nВсе индексы i, L, R нумеруются с нуля. Все числа в запросах целые. Все запросы корректны. Пример запроса: “+ 0 x” означает “добавление x в начало массива”. Исходное число элементов в массиве — 0 \r\n N \r\n 105, числа в массиве по модулю не превышают 109. Число запросов — 1 \r\n K \r\n 105.\r\n\r\nФормат вывода\r\nДля каждого запроса в отдельной строке выведите одно число — ответ на запрос.','Нужно вставлять, удалять элементы, а также на отрезке находить сколько элементов не превосходят данного числа.','Можно моделировать процесс при помощи sqrt-декомпозиции. ','ЯК 12973 F5',''),(163,'Быстрое прибавление',27,'Есть массив целых чисел длины \r\nn\r\n=\r\n2\r\n2\r\n4\r\n, изначально заполненных нулями. Вам нужно сперва обработать \r\nm\r\n случайных запросов вида “прибавление на отрезке”. Затем обработать \r\nq\r\nслучайных запросов вида “сумма на отрезке”.\r\nФормат ввода\r\nНа первой строке числа \r\nm\r\n, \r\nq\r\n ( \r\n1\r\n≤\r\nm\r\n,\r\nq\r\n≤\r\n2\r\n2\r\n4\r\n). На второй строке пара целых чисел \r\na\r\n, \r\nb\r\n от \r\n1\r\n до \r\n1\r\n0\r\n9\r\n, используемая в генераторе случайных чисел. \r\n0. unsigned int a, b; // даны во входных данных \r\n1. unsigned int cur = 0; // беззнаковое 32-битное число \r\n2. unsigned int nextRand() { \r\n3.   cur = cur * a + b; // вычисляется с переполнениями \r\n4.   return cur » 8; // число от \r\n0\r\n до \r\n2\r\n2\r\n4\r\n−\r\n1\r\n.\r\n5. }\r\nКаждый запрос первого вида генерируется следующим образом: \r\n1. add = nextRand(); // число, которое нужно прибавить \r\n2. l = nextRand(); \r\n3. r = nextRand(); \r\n4. if (l > r) swap(l, r); // получили отрезок [l..r]\r\nКаждый запрос второго вида генерируется следующим образом: \r\n1. l = nextRand(); \r\n2. r = nextRand(); \r\n3. if (l > r) swap(l, r); // получили отрезок [l..r]\r\nСперва генерируются запросы первого вида, затем второго.\r\n\r\nФормат вывода\r\nВыведите сумму ответов на все запросы второго типа по модулю \r\n2\r\n3\r\n2\r\n.\r\n','Нужно сначала обработать много запросов \"прибавить на отрезке\", а затем много запросов \"сумма на отрезке\"','Когда от нас просят прибавить на отрезке, будем вместо этого прибавлять в его левой границы, а вычитать из числа, следующего за правой. Заметим, что на данном массиве массив префиксных сумм будет массивом, на котором нам надо находить суммы на отрезке. Посчитаем на нем ещё раз префиксную сумму и с помощью нее будем отвечать за запросы.\r\n\r\nТаким образом, на каждый запрос мы отвечаем за O(1)','ЯК 12973 G5',''),(164,'Серёжа и скобочки',31,'У Сережи есть скобочная последовательность \r\ns\r\n1\r\n,\r\ns\r\n2\r\n,\r\n…\r\n,\r\ns\r\nn\r\n, или, другими словами, строка \r\ns\r\nдлины \r\nn\r\n, состоящая из символов « (» и « )».\r\nСереже нужно ответить на \r\nm\r\n запросов, каждый из которых характеризуется двумя целыми числами \r\nl\r\ni\r\n,\r\nr\r\ni\r\n \r\n(\r\n1\r\n≤\r\nl\r\ni\r\n≤\r\nr\r\ni\r\n≤\r\nn\r\n)\r\n. Ответом на \r\ni\r\n-ый запрос является длина наибольшей правильной скобочной подпоследовательности последовательности \r\ns\r\nl\r\ni\r\n,\r\ns\r\nl\r\ni\r\n+\r\n1\r\n,\r\n…\r\n,\r\ns\r\nr\r\ni\r\n. Помогите Сереже ответить на все запросы.\r\nОпределения подпоследовательности и правильной скобочной последовательности смотрите в примечаниях.\r\n\r\nФормат ввода\r\nПервая строка содержит последовательность символов без пробелов \r\ns\r\n1\r\n,\r\ns\r\n2\r\n,\r\n…\r\n,\r\ns\r\nn\r\n (\r\n1\r\n≤\r\nn\r\n≤\r\n1\r\n0\r\n6\r\n)\r\n. Каждый символ это либо « (», либо « )». Вторая строка содержит целое число \r\nm\r\n \r\n(\r\n1\r\n≤\r\nm\r\n≤\r\n1\r\n0\r\n5\r\n)\r\n количество запросов. Каждая из следующих \r\nm\r\n строк содержит пару целых чисел. В \r\ni\r\n-ой строке записаны числа \r\nl\r\ni\r\n,\r\nr\r\ni\r\n \r\n(\r\n1\r\n≤\r\nl\r\ni\r\n≤\r\nr\r\ni\r\n≤\r\nn\r\n)\r\n — описание \r\ni\r\n-го запроса.\r\nФормат вывода\r\nВыведите ответ на каждый запрос в отдельной строке. Ответы выводите в порядке следования запросов во входных данных.\r\n','Дана скобочная последовательность, необходимо для данных отрезков сказать длину максимальной правильной скобочной подпоследовательности на данном отрезке.','Заведем дерево отрезков. В каждой вершине будем хранить три значения - размер максимальной правильной скобочной подпоследовательности, количество открывающих скобок, не вошедших в нее и количество закрывающих скобок, не вошедших в нее. Для объединения двух вершин достаточно объединить их ПСП, а также не использованные открытые скобки из левой вершины и неиспользованные закрытые из правой.','ЯК 12973 H5',''),(165,'Фаброзавры-дизайнеры',50,'Фаброзавры известны своим тонким художественным вкусом и увлечением ландшафтным дизайном. Они живут около очень живописной реки и то и дело перестраивают тропинку, идущую вдоль реки: либо насыпают дополнительной земли, либо срывают то, что есть. Для того, чтобы упростить эти работы, они поделили всю тропинку на горизонтальные участки, пронумерованные от 1 до N, и их переделки устроены всегда одинаково: они выбирают часть дороги от L-ого до R-ого участка (включительно) и изменяют (увеличивают или уменьшают) высоту на всех этих участках на одну и ту же величину (если до начала переделки высоты были разными, то и после переделки они останутся разными).\r\n\r\nПоскольку, как уже говорилось, у фаброзавров тонкий художественный вкус, каждый из них считает, что их река лучше всего выглядит с определенной высоты. Поэтому им хочется знать, есть ли поблизости от их дома место на тропинке, где высота на их взгляд оптимальна. Помогите им в этом разобраться.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит два числа N и M — длину дороги и количество запросов соответственно (). На второй строке содержатся N чисел, разделенных пробелами — начальные высоты соответствующих частей дороги; высоты не превосходят 104 по модулю. В следующих M строках содержатся запросы по одному на строке.\r\n\r\nЗапрос +  означает, что высоту частей дороги от L-ой до R-ой (включительно) нужно изменить на X. При этом , а .\r\n\r\nЗапрос ?  означает, что нужно проверить, есть ли между L-ым и R-ым участками (включая эти участки) участок, где дорога проходит точно на высоте X. Гарантируется, что , а .\r\n\r\nФормат вывода\r\nНа каждый запрос второго типа нужно вывести в выходной файл на отдельной строке одно слово «YES» (без кавычек), если нужный участок существует, и «NO» в противном случае.','Требуется прибавлять на отрезке и проверять наличие данного числа на отрезке.','Можно решать задачу корневой декомпозицией. Либо деревом отрезков декартовых деревьев.','ЯК 12973 I5',''),(166,'Двоичное дерево поиска',20,'Реализуйте сбалансированное двоичное дерево поиска.\r\n\r\nФормат ввода\r\nВходной файл содержит описание операций с деревом, их количество не превышает 100000. В каждой строке находится одна из следующих операций.\r\n\r\ninsert x – добавить в дерево ключ x. Если ключ x уже в дереве, то ничего делать не надо.\r\ndelete x – удалить из дерева ключ x. Если ключа x в дереве нет, то ничего делать не надо.\r\nexists x – если ключ x есть в дереве, выведите «true», иначе «false»\r\nВсе числа во входном файле целые и по модулю не превышают 109.\r\n\r\nФормат вывода\r\nВыведите последовательно результат выполнения всех операций exists. Следуйте формату выходного файла из примера.\r\n\r\n','Необходимо добавлять и удалять элемент из множества, а также проверять его наличие.','Предполагается решение декартовым деревом, но set тоже заходит. Видимо, задача нужна, чтобы потренироваться перед следующей.','ЯК 12973 A6',''),(167,'Двоичное дерево поиска 2',40,'Реализуйте сбалансированное двоичное дерево поиска.\r\n\r\nФормат ввода\r\nВходной файл содержит описание операций с деревом, их количство не превышает 105. В каждой строке находится одна из следующих операций.\r\n\r\ninsert x – добавить в дерево ключ x.\r\n\r\ndelete x – удалить из дерева ключ x. Если его там нет, то ничего делать не надо.\r\n\r\nexists x – если ключ x есть в дереве, выведите «true», иначе, «false»\r\n\r\nnext x – выведите минимальный элемент в дереве, строго больший x или «none», если такого нет.\r\n\r\nprev x – выведите максимальный элемент в дереве, строго меньший x или «none», если такого нет.\r\n\r\nkth x – выведите k-тый по величине элемент(нумерация с единицы). Если такого не существует, то выведите «none».\r\n\r\nВсе числа во входном файле не превышают 109.\r\n\r\nФормат вывода\r\nВыведите последовательно результат выполнения всех операций exists, next, prev. Следуйте формату выходного файла из примера.\r\n\r\n','Необходимо вставлять и удалять элементы из множества, а также проверять существование элемента, находить первый, больший данного, последний, меньший данного, k-й по возрастанию элемент.','Декартово дерево по явному ключу','ЯК 12973 B6',''),(168,'Декартово дерево',34,'Вам даны пары чисел (ai, bi). Вам необходимо построить декартово дерево, такое что i-ая вершина имеет ключи (ai, bi), вершины с ключом ai образуют бинарное дерево поиска, а вершины с ключом bi образуют кучу.\r\n\r\nФормат ввода\r\nВ первой строке записано число N — количество пар. Далее следует N () пар (ai, bi). Для всех пар |ai|,  . ai ≠ aj и bi ≠ bj для всех i ≠ j .\r\n\r\nФормат вывода\r\nЕсли декартово дерево с таким набором ключей построить возможно, выведите в первой строке YES, в противном случае выведите NO. В случае ответа YES, выведите N строк, каждая из которых должна описывать вершину. Описание вершины состоит из трёх чисел: номер предка, номер левого сына и номер правого сына. Если у вершины отсутствует предок или какой-либо из сыновей, то выводите на его месте число 0.\r\n\r\nЕсли подходящих деревьев несколько, выведите любое.\r\n\r\n','Построить декартово дерево с данными ключами и приоритетами.','Из-за неслучайных приоритетов обычное построение превратится в квадратичный алгоритм. Тут нужно построить его либо при помощи сортировки слиянием, либо со стеком.','ЯК 12973 C6',''),(169,'Слоники',60,'Это интерактивная задача.\r\n\r\nДобро пожаловать в самый большой в мире рынок слоников! Так как вы новичок на этом рынке, вашей целью является научиться анализировать текущее состояние рынка. Вы должны понимать, сколько денег вы можете заработать в любой момент времени, исходя из текущих предложений, совершая любые покупки и продажи, какие вы хотите. Но вы не будете торговать в реальности. Только анализировать.\r\n\r\nРынок слоников имеет следующую модель: продавцы могут сами назначить цену на слоника, а покупатели – запросить слоника за определенную цену. Цены меняются постоянно, как только торговцам это взбредет в голову.\r\n\r\nМы подразумеваем, что вам дана текущая ситуация рынка, и вы можете купить несколько слоников и сразу их продать. Вы покупаете и продаете слоников в течение минуты. Вы не заинтересованы в хранении слоников. Так же вы можете покупать и продавать столько слоников, сколько вы захотите!\r\n\r\nНа открытии рынка слоников никто не хочет покупать или продавать слоников. Известно лишь, какие изменения происходят на рынке. Для простоты будем считать, что изменения имеют следующий вид: “buy 10 100”. Это значит, что спрос на слонов стал на 10 слонов больше с ценой спроса 100. Или “sell -3 99”, что обозначает, что предложение слонов стало на 3 слона меньше, а цена продажи стала 99.\r\n\r\nНапишите программу, которая вычисляет максимальную прибыль, которую вы можете получить после перепродажи слонов. Заметьте, что вы не совершаете никаких продаж и покупок, это значит, что при появлении нового предложения (или изменения количества слоников с такой ценой), все предыдущие предложения еще действительны.\r\n\r\nФормат ввода\r\nВаша программа должна принимать предложения с рынка последовательно, в следующем формате: каждая строка входных данных обозначает предложение, и начинается с типа предложения (одна из строчек “buy”, “sell” или “end”), которая обозначает, что изменилось количество покупаемых или продаваемых слоников, либо изменения закончились.\r\n\r\nПредложение “end” больше ничего не содержит, и после него ваша программа должна непременно закончить работу.\r\n\r\nДругие предложения содержат по 2 числа, разделенных пробелом D и P, где D – изменение количества продаваемых или покупаемых слоников по цене P за каждого.(-106 ≤ D ≤ 106, 1 ≤ P ≤ 109). Суммарное число всех предложений не превышает 105. Для лучшего понимания, смотрите примеры.\r\n\r\nГарантируется, что сумма цен всех за всех продаваемых слоников и сумма цен за всех покупаемыхслоников на каждый момент времени не превышает 262, и что число слоников для каждой цены для покупки или продажи никогда не отрицательно.\r\n\r\nФормат вывода\r\nДля каждого “buy” или “sell”, вы должны вывести число в отдельной строке: максимальную прибыль в пиастрах, которую вы можете получить, занимаясь перепродажей слоников. Не забывайте делать перевод строки и flush.\r\n\r\nПримечания\r\nВход от интерактора\r\n\r\nbuy 10 100\r\n\r\nsell 4 98\r\n\r\nbuy -7 100\r\n\r\nbuy 2 99\r\n\r\nsell 1 97\r\n\r\nend\r\n\r\nОтветы программы участника:\r\n\r\n0\r\n\r\n8\r\n\r\n6\r\n\r\n7\r\n\r\n9','Приходят люди, которые за определенную цену готовы покупать или продавать слонов. Требуется каждый раз говорить, какую максимальную сумму можно выручить','Нужно сделать аккуратный бинпоиск на декартовом дереве, которое поддерживает всех текущих слонов.','ЯК 12973 D6','Написать более подробный разбор'),(170,'И снова сумма...',34,'Реализуйте структуру данных, которая поддерживает множество S целых чисел, с котором разрешается производить следующие операции:\r\n\r\nadd(i) — добавить в множество S число i (если он там уже есть, то множество не меняется);\r\nsum(l, r) — вывести сумму всех элементов x из S, которые удовлетворяют неравенству l ≤ x ≤ r.\r\nФормат ввода\r\nИсходно множество S пусто. Первая строка входного файла содержит n — количество операций (1 ≤ n ≤ 300 000).Следующие n строк содержат операции. Каждая операция имеет вид либо «+ i», либо «? l r». Операция «? l r» задает запрос sum(l, r).\r\n\r\nЕсли операция «+ i» идет во входном файле в начале или после другой операции «+», то она задает операцию add(i). Если же она идет после запроса «?», и результат этого запроса был y, то выполняется операция .\r\n\r\nВо всех запросах и операциях добавления параметры лежат в интервале от 0 до 109.\r\n\r\nФормат вывода\r\nДля каждого запроса выведите одно число — ответ на запрос.','Необходимо добавлять элементы, а также находить сумму элементов, значения которых лежат в данных границах.','Поддерживаем декартово дерево по явному ключу с суммой в поддереве.','ЯК 12973 E6',''),(171,'Последовательность и палиндромы',24,'Задана последовательность из N целых чисел. Сколькими способами можно покрасить некоторое ненулевое количество элементов в красный цвет так, чтобы образуемая красными элементами подпоследовательность была палиндромом?\r\n\r\nНапример, в случае из примера существует 7 способов раскраски: первый, третий и четвёртый элементы (последовательность 1 3 1), первый, второй и четвёртый (последовательность 1 2 1), первый и четвёртый (последовательность 1 1), а также четыре способа, при которых в красный цвет окрашивается только один элемент.\r\n\r\nПоскольку ответ может быть очень большим, выведите его по модулю 109.\r\n\r\nФормат ввода\r\nПервая строка входного файла содержит число N – количество чисел в последовательности (1 ≤ N ≤ 2000). Вторая строка содержит N целых чисел — исходную последовательность. Все элементы последовательности положительны и не превышают 109.\r\n\r\nФормат вывода\r\nВыведите в выходной файл одно число — искомое число способов по модулю 109.\r\n\r\n','Найти количество подпоследовательностей-палиндромов в строке.','Решается простым дп на подотрезках','ЯК 12973 F6',''),(172,'Количество инверсий',55,'Вам дана перестановка. Вам надо отвечать на запросы следующих типов:\r\n\r\n0 - запрос на вывод количества инверсий в перестановке. Инверсия - это такая пара (i, j), что i < j и ai > aj, где a - данная перестановка.\r\n\r\n1 L R - запрос, который требует поменять местами числа, стоящие на L и R месте в перестановке.\r\n\r\nФормат ввода\r\nВ первой строке вам даны два числа - N и M (1 ≤ N, M ≤ 105) - количество чисел в перестановке и количество запросов. В следующей строке вам дано N различных натуральных чисел - сама перестановка. Все они не превосходят N. В следующих M строках вам даны запросы. Каждый запрос имеет либо вид 0, либо 1 L R (1 ≤ L, R ≤ N) - параметры запроса.\r\n\r\nФормат вывода\r\nНа каждый запрос типа 0 в отдельное строке выведите ответ - количество инверсий в массиве в данный момент.\r\n\r\n','Требуется менять местами два элемента перестановки и после каждой замены находить количество инверсий.','Заведем дерево отрезков декартовых деревьев. С помощью него мы можем отвечать на запросы вида \"количество элементов на данном отрезке, не превосходящие данного числа\". Зная это количество, можно быстро пересчитывать количество инверсий после свопа.','ЯК 12973 G6','');
/*!40000 ALTER TABLE `tasks` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tasks_contest`
--

DROP TABLE IF EXISTS `tasks_contest`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tasks_contest` (
  `contest_id` int(11) NOT NULL,
  `task_id` int(11) NOT NULL,
  KEY `contest_id` (`contest_id`),
  KEY `task_id` (`task_id`),
  CONSTRAINT `tasks_contest_ibfk_1` FOREIGN KEY (`contest_id`) REFERENCES `contests` (`id`),
  CONSTRAINT `tasks_contest_ibfk_2` FOREIGN KEY (`task_id`) REFERENCES `tasks` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tasks_contest`
--

LOCK TABLES `tasks_contest` WRITE;
/*!40000 ALTER TABLE `tasks_contest` DISABLE KEYS */;
INSERT INTO `tasks_contest` VALUES (1,72),(1,73),(1,74),(1,75),(1,76),(1,77),(1,78),(1,79),(2,80),(2,81),(2,82),(2,83),(2,84),(3,85),(3,86),(3,87),(3,88),(3,89),(3,90),(4,91),(4,92),(4,93),(4,94),(4,95),(4,96),(4,97),(4,98),(4,99),(4,100),(4,101),(5,102),(5,103),(5,104),(5,105),(5,106),(6,107),(6,108),(6,109),(6,110),(6,111),(6,112),(6,113),(7,114),(7,115),(7,116),(7,117),(7,118),(7,119),(8,150),(8,151),(8,152),(8,153),(8,154),(8,155),(8,156),(10,126),(10,127),(10,128),(10,129),(10,130),(10,131),(10,132),(10,133),(12,143),(12,144),(12,145),(12,146),(12,147),(12,148),(12,149),(9,120),(9,121),(9,122),(9,123),(9,124),(9,125),(11,134),(11,135),(11,136),(11,137),(11,138),(11,139),(11,140),(11,141),(11,142),(13,157),(13,158),(13,159),(13,160),(13,161),(13,162),(13,163),(13,164),(13,165),(14,166),(14,167),(14,168),(14,169),(14,170),(14,171),(14,172);
/*!40000 ALTER TABLE `tasks_contest` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) COLLATE utf8_unicode_ci DEFAULT NULL,
  `login` varchar(50) COLLATE utf8_unicode_ci NOT NULL,
  `password_hash` varchar(200) COLLATE utf8_unicode_ci NOT NULL,
  `level` int(11) NOT NULL,
  `approved` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `login` (`login`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (1,'Невструй','veschii_nevstrui','pbkdf2:sha256:150000$eMuS7SjL$0cb97eda59ce76cd49998650f4a3e0a16c584f6dda0fbb0ffea56717795f94f3',0,1);
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Current Database: `task_base_test`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `task_base_test` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci */;

USE `task_base_test`;

--
-- Table structure for table `contests`
--

DROP TABLE IF EXISTS `contests`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `contests` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  `year` int(11) NOT NULL,
  `description` longtext COLLATE utf8_unicode_ci,
  `link` varchar(200) COLLATE utf8_unicode_ci NOT NULL,
  `tutorial` varchar(100) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `contests`
--

LOCK TABLES `contests` WRITE;
/*!40000 ALTER TABLE `contests` DISABLE KEYS */;
INSERT INTO `contests` VALUES (1,'??? ?????? ???????',2020,'???????? ????? ??????? ????????','?????? ?? ??? ?????? ???????',NULL),(2,'????',123,'????','????????',NULL),(3,'ывпивапи',2222,'ыамывам','ывамывам',NULL),(4,'вк',1111,'Контест, который тестирует внешние ссылки','vk.com',NULL),(5,'sdfvsdfv',0,'vsdfvsdfvsdfv','https://vk.com',NULL),(6,'dsfsdfvsdfv',0,'sdfvsdfvsdf','https://vk.com',NULL),(7,'Контест с 5 задачами',5,'4 задач должно быть здесь и ни задачей меньше','https://v7k.com','');
/*!40000 ALTER TABLE `contests` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tags`
--

DROP TABLE IF EXISTS `tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag` varchar(100) NOT NULL,
  `parent` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `tag` (`tag`),
  KEY `parent` (`parent`),
  CONSTRAINT `tags_ibfk_1` FOREIGN KEY (`parent`) REFERENCES `tags` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tags`
--

LOCK TABLES `tags` WRITE;
/*!40000 ALTER TABLE `tags` DISABLE KEYS */;
INSERT INTO `tags` VALUES (1,'segment tree',3),(2,'2-SAT',NULL),(3,'easy',NULL),(4,'binary search',NULL),(5,'dp',NULL),(6,'bfs',NULL),(7,'dfs',NULL),(8,'difficult',NULL),(9,'dijkstra',NULL),(10,'game',NULL),(11,'tag1',NULL),(12,'tag2',NULL),(13,'tag3',NULL),(14,'tag4',NULL),(16,'Tag7',NULL),(17,'tag8',2),(18,'tag9',17),(20,'tag10',NULL),(21,'tag11',10),(22,'tag12',21),(23,'tag13',21);
/*!40000 ALTER TABLE `tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tags_task`
--

DROP TABLE IF EXISTS `tags_task`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tags_task` (
  `task_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL,
  KEY `task_id` (`task_id`),
  KEY `tag_id` (`tag_id`),
  CONSTRAINT `tags_task_ibfk_1` FOREIGN KEY (`task_id`) REFERENCES `tasks` (`id`),
  CONSTRAINT `tags_task_ibfk_2` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tags_task`
--

LOCK TABLES `tags_task` WRITE;
/*!40000 ALTER TABLE `tags_task` DISABLE KEYS */;
INSERT INTO `tags_task` VALUES (35,5),(39,5),(39,5),(42,3),(42,2),(44,2),(50,2),(50,2),(50,2),(52,2),(52,2),(52,2),(54,4),(54,4),(54,4),(55,4),(55,4),(55,4),(59,4),(59,4),(59,4),(60,4),(60,4),(60,4),(62,3),(62,3),(62,2),(63,2),(63,2),(63,2),(65,1),(65,1),(65,1),(66,2),(66,5),(66,4),(67,2),(67,4),(67,5),(67,1),(68,2),(68,4),(68,5),(68,1),(69,2),(69,5),(69,1),(71,2),(71,4),(71,1),(72,2),(73,2),(73,4),(73,3),(74,5),(74,3),(74,1),(75,6),(75,5),(75,1),(70,1),(70,8),(76,5),(76,4),(76,3),(76,1),(61,2),(61,6),(61,3),(77,2),(77,8),(56,4),(56,4),(56,4),(43,5),(43,3),(43,2),(43,1),(51,1),(51,1),(51,1),(78,1),(82,2),(87,1),(87,8),(87,9),(29,12),(29,11),(53,5),(53,1),(53,12),(49,3),(49,3),(40,9),(88,11),(88,12),(89,1),(89,3),(24,1),(24,3),(32,6),(57,2),(64,16),(64,4),(64,5),(90,17),(90,2),(90,18),(91,1),(91,3),(92,20),(93,10),(93,21),(93,23),(94,13),(95,10),(95,21),(95,23),(96,17),(96,2),(96,18),(97,9),(98,10),(98,21),(98,23),(99,10),(99,21),(99,23),(100,17),(100,2),(100,18),(100,21),(100,23),(100,10),(101,17),(101,2),(102,10),(102,21),(102,23);
/*!40000 ALTER TABLE `tags_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tasks`
--

DROP TABLE IF EXISTS `tasks`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tasks` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(500) NOT NULL,
  `complexity` int(11) DEFAULT NULL,
  `statement` mediumtext,
  `short_statement` varchar(10000) NOT NULL,
  `tutorial` mediumtext,
  `source` varchar(10000) DEFAULT NULL,
  `todo` mediumtext,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=103 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tasks`
--

LOCK TABLES `tasks` WRITE;
/*!40000 ALTER TABLE `tasks` DISABLE KEYS */;
INSERT INTO `tasks` VALUES (6,'1',5,'3','2','4','6',''),(7,'Имя',0,'Длинное условие','Короткое условие','Разбор','Снарк',''),(8,'Имя',0,'Длинное условие','Короткое условие','Разбор','Снарк',''),(9,'Имя',0,'Длинное условие','Короткое условие','Разбор','Снарк',''),(10,'123',13,'789','456','101112','14',''),(11,'1',1,'1','1','1','1',''),(12,'1',1,'1','1','1','1',''),(13,'1',0,'','1\r\n2\r\n','','',''),(14,'abcdefghijklmnop',123,'qweqweqweqweqwe','ssssssssssssssss','123','123',''),(15,'abcdefghijklmnop',0,'qweqweqweqweqwe','ssssssssssssssss','','',''),(24,'Мишка любит мёд228332',13,'\\','Единорожка топ','Настя топ','Влад','Поспать'),(29,'qweqweqwe',12,'431','qweqweqwe','qeqweqweqweqwe','113179',''),(30,'123',4312,'41','321','1234','1234',''),(31,'1234',234,'1234','431','5423','123',''),(32,'123',6543,'5423','4312','2345','764',''),(35,'123',1234,'1234','4312','41234','4321',''),(39,'123',1234,'1234','4312','41234','4321',''),(40,'113179',213,'123','321','321','312',''),(42,'Manmnasdfvsdfvsdfv',0,'','sdfv','Его раньше не было, а тут он хоп и появился','',''),(43,'Настя',0,'Владислав приготовил $2^n$ блинчиков. Требуется сказать, сколько блинчиков он приготовил бы, если бы был более мотивирован.\r\n','2^n\r\n','Ну тут и разбираться не надо','0',''),(44,'444',888,'666','555','777','999',''),(49,'sdfv',0,'dudnhbxfv\r\nkinchrbg\r\n\r\nuikyjnthbg','sdfv\r\n\r\njnbtyhvtvg\r\n\r\njn6ujbtyhb','','',''),(50,'321',123,'321','123','321','321',''),(51,'24352',0,'\\begin{enumerate}\r\n\\item первый\r\n\\item второй\r\n\\item третий\r\n\\end{enumerate}\r\n\r\nПример текста с вербатимом','Много текста','','',''),(52,'62456',0,'','3456367','','',''),(53,'1253',0,'Нормальное условие чтобы было','5342','Нормальный разбор чтобы был','Источник - моя головушка','Поправить сложности во всех более ранних задачах. Кажется, я их немного неадекватно выставляю'),(54,'4132',0,'1235','14235','','',''),(55,'4123',0,'2354','26345','','',''),(56,'sdfv',0,'','vsdfv','01234567890123456789012345678901234567890123456789012345678901234567','',''),(57,'sdfv',0,'','asdf','','',''),(59,'51235',0,'','2345234','','',''),(60,'sdfv',0,'','sdfv','','',''),(61,'Настя самая замечательная',0,'','gsdf','','','Большая тудушка'),(62,'gergt',0,'','ergtert','','',''),(63,'sdfv',0,'','sdfv','','',''),(64,'sdfv',0,'','vfds','','',''),(65,'sdfvsdf',0,'sdfgsdfg','sdfgsdfv','','',''),(66,'123',0,'','sdfvsdfgsdfg','','',''),(67,'dgfbdgfb',0,'dfghdfgb','dfghdfgh','','',''),(68,'dgfbdgfb',0,'dfghdfgb','dfghdfgh','','',''),(69,'Анастасия',0,'','Топовая','','',''),(70,'Настя самая замечательная',113,'Топовая','Самая','В мире','Точно','Говорю'),(71,'Владислав',0,'Топовые','И Анастасия','','',''),(72,'1243',0,'vsdfvsdfv','vsdfv','Филипп читает лекцию','ыхашщмт','двлаомт'),(73,'Имя',0,'Длинное условие','Короткое условие','Разбор','Источник','Туду'),(74,'Настя',0,'ывамывам','Топ','ыдваомтыдво','ывдаомтывам',''),(75,'Добавляю задачу',99,'И еще одну','Ещё одну','много задач','Которые надо добавить','Добавить все задачи в мире'),(76,'Новое название',179,'Не нужно','Короткое условие','Не нужно','Не нужно','Не нужно'),(77,'4131234',142345,'63456','542','53','54232345','542345'),(78,'sdfv',0,'sdfvsdfv','sdfvsdfv','sdfvsdfv','',''),(80,'113113',123,'ewqqweewq','qweewqqwe','qwewqqwe','ewqqweewq','qweewqqwe'),(81,'123123431',123,'q3rwervf','43123wef','34refdsc','321123231','123123123213'),(82,'Norm name',123,'123','123','123','123','123'),(85,'000000',0,'000000000000','0000000000','0000000000000','000000','0000000000'),(86,'00000000000',0,'00','00','000','000','000'),(87,'Должно добавиться',1,'Добавляйся!','Добавляйся!','Добавляйся!','Добавляйся!','Добавляйся!'),(88,'gbdfgb',0,'bdfgbdfgbdfg','dfgbdfgbdfg','bdfgbdfgbdfgbdfgbd','wrtgd','tyjmhfn'),(89,'12341234',12341234,'1241234','13241234','12341234','12341234','12341234'),(90,'Task1',0,'','sdfv','','',''),(91,'Task2',0,'','sfv','','',''),(92,'Task3',0,'','dfgb','','',''),(93,'Task4',0,'','sdfvsdfv','','',''),(94,'Task5',0,'','dfgbdfgb','','',''),(95,'Task6',0,'','dfgbdfgb','','',''),(96,'Task7',0,'','sdvf','','',''),(97,'Task12',0,'','sdfv','','',''),(98,'sdfvsdfv',0,'','sdfvsdfv','','',''),(99,'qwer',0,'','req','','',''),(100,'Новая задача 7 контеста',0,'','Задача','','',''),(101,'Задача2',0,'','Новая задача для седьмого контеста','','',''),(102,'Задача в контест',0,'','Настя топ','','','');
/*!40000 ALTER TABLE `tasks` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tasks_contest`
--

DROP TABLE IF EXISTS `tasks_contest`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tasks_contest` (
  `contest_id` int(11) NOT NULL,
  `task_id` int(11) NOT NULL,
  KEY `contest_id` (`contest_id`),
  KEY `task_id` (`task_id`),
  CONSTRAINT `tasks_contest_ibfk_1` FOREIGN KEY (`contest_id`) REFERENCES `contests` (`id`),
  CONSTRAINT `tasks_contest_ibfk_2` FOREIGN KEY (`task_id`) REFERENCES `tasks` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tasks_contest`
--

LOCK TABLES `tasks_contest` WRITE;
/*!40000 ALTER TABLE `tasks_contest` DISABLE KEYS */;
INSERT INTO `tasks_contest` VALUES (1,24),(1,70),(4,43),(7,32),(7,61),(7,71),(7,75),(7,32),(7,61),(7,71),(7,75),(7,100),(7,101),(7,102);
/*!40000 ALTER TABLE `tasks_contest` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) COLLATE utf8_unicode_ci DEFAULT NULL,
  `login` varchar(50) COLLATE utf8_unicode_ci NOT NULL,
  `password_hash` varchar(200) COLLATE utf8_unicode_ci NOT NULL,
  `level` int(11) NOT NULL,
  `approved` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`login`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (1,'Невструй','veschii_nevstrui','pbkdf2:sha256:150000$yA18wNCn$69043c64e99ea39ce9b279155e175ecbd66610a2abf14dbeab94118c87c41edb',0,1),(3,'Филипп','dpr_pavlin','pbkdf2:sha256:150000$Ab6BYqDT$bfaad5b368bfc822c1a550c7679d3527c2b77b8e841abaf29aa7586247359ef3',0,1);
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-12-08 15:21:58
